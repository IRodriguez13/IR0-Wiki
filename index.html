<!DOCTYPE html>
<html lang="es">
<!-- Si estás leyendo esto, primero ya te dije que no estoy usando ningún framework de moda hipster como React, next, nest, lo que sea. A lo sumo Blazor. -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IR0 Kernel - Wiki</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <script src="main.js"></script>

    <nav class="navbar">
        <div class="nav-container">
            <div class="logo"><a href="index.html" target="_blank" rel="noopener noreferrer"
                    style="text-decoration: none; color: white;">IR0 Wiki</a></div>
            <ul class="nav-menu">
                <li><a href="#overview" class="nav-link active" onclick="showSection('overview')">Overview</a></li>
                <li><a href="#architecture" class="nav-link" onclick="showSection('architecture')">Arquitectura</a></li>
                <li><a href="#branches" class="nav-link" onclick="showSection('branches')">Ramas</a></li>
                <li><a href="#development" class="nav-link" onclick="showSection('development')">Desarrollo</a></li>
                <li><a href="#panic" class="nav-link" onclick="showSection('panic')">Subsistemas</a></li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <section id="overview" class="section active">
            <h1 class="titulo-principal">IR0 Kernel - Overview</h1>

            <div class="info-card">
                <p>
                    El propósito de esta "wiki", documentación web, guía, como le digas, es usarla como ayuda-memoria personal
                    para el desarrollo del kernel.
                    No tiene que ser una página ultra estética, pero me estoy esforzando para que no se note que la hice
                    con html, css y js vanilla como la de <a href="https://docs.kernel.org/" target="_blank"
                        rel="noopener noreferrer">algún proyecto aficionado</a>
                    que anda por ahí. <br> <br>
                    Un kernel de sistema operativo mínimamente funcional (todo el kernel space más un user space mínimo)
                    puede andar fácilmente en las <strong>15.000</strong> líneas de código por lo que, como verás;
                    es humanamente imposible memorizar y comprender todo el flujo del kernel por mí mismo. Además son
                    muchos subsistemas complejos trabajando a bajo nivel juntos para intermediar entre hardware y
                    software.
                </p>
            </div>


            <div class="info-card">
                <h2>¿Qué es IR0?</h2>
                <p>
                    <strong>IR0</strong> es un <strong>kernel de sistema operativo multipropósito</strong> desarrollado
                    desde cero para arquitectura
                    <strong>x86-32</strong> escrito principalmente en <strong>C</strong> y <strong>ASM</strong> (Aunque
                    no tengo ningún problema en incluir código de otros lenguajes especializados en performance como
                    <strong>Cpp</strong> o <strong>Rust</strong>).
                    <br>
                    Lo estoy creando para aprender más sobre sistemas operativos y poder usarlo como materia
                    prima para otro proyecto que replica a <a href="https://learn.microsoft.com/es-es/windows/wsl/about"
                        target="_blank" rel="noopener noreferrer">WSL2</a> pero con mi propio kernel.
                    No descarto escalarlo lo suficiente como para hacerlo usable en servidores mínimos o incluso IoT,
                    pero entiendo que eso es al largo <i>(larguísimo)</i> plazo.
                </p>
            </div>


            <div class="info-card">
                <h2>Características Principales y las futuras</h2>
                <ul class="feature-list">
                    <li>Kernel monolítico para arquitectura x86-64</li>
                    <li>Gestión de memoria con paging en esas dos arquitecturas</li>
                    <li>Manejo de interrupciones y excepciones</li>
                    <li>Bootloader personalizado (Sólo en x86 y segúramente migre todas las arquitecturas a GRUB)</li>
                    <li>El código ensamblador que uso es en sintaxis de <a
                            href="https://cs.lmu.edu/~ray/notes/nasmtutorial/" target="_blank"
                            rel="noopener noreferrer">Intel Netwide Assembler (nasm)</a>.</li>
                    <li>Filesystem propio basado en EXT con optimización con bbdd vectorial en espacio de usuario</li>
                    <li>Pila de red y <a href="https://opensource.com/article/22/12/linux-abi" target="_blank"
                            rel="noopener noreferrer">ABI</a> prestados de Linux (Son millones de líneas de código que
                        no pienso escribir solo)</li>
                    <li>Syscalls propias y algunas mapeadas de Linux</li>
                    <li>Algunos drivers para manejo de hardware mínimo.</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>Estado del Proyecto</h2>
                <p><strong>Versión:</strong> no versionado aún (pero vamos a decir pre-release)<br>
                    <strong>Arquitectura:</strong> x86-32 (i386)<br>
                    <strong>Bootloader:</strong> GRUB<br>
                    <strong>Sintaxis ASM:</strong> Intel
                </p>
            </div>
        </section>

        <section id="architecture" class="section">
            <h1 class="titulo-principal">Arquitectura del Sistema</h1>

            <div class="architecture-box">
                <img src="Assets/scheme-core.png" alt="ir0-arch" srcset="">
            </div>
            <div class="info-card">
                <h2>Arquitectura y "Filosofía" del proyecto</h2>
                <p>
                    A diferencia de kernels como <a href="https://en.wikipedia.org/wiki/Windows_NT" target="_blank" rel="noopener noreferrer">kernel NT (Híbrido)</a> de Microsoft, <a href="https://www.redox-os.org/" target="_blank" rel="noopener noreferrer">Redox-OS (Microkernel)</a>, 
                    o el mismo <a href="https://es.wikipedia.org/wiki/MINIX" target="_blank" rel="noopener noreferrer">MINIX kernel (microkernel)</a>, IR0 se basa en una arquitectura más similar a la que tiene Linux, que es monolítico. <br>
                    sin embargo, mi argumento principal es el del rendimiento. Entiendo que alguien podría venir y señalar que, como todo monolito, si un subcomponente se rompe, se cae todo el sistema <small>(y tendría razón)</small>
                    pero lo que respondo a eso es que <i>"¿De qué me sirve a mí que el kernel soporte seguir sin filesystem si no puedo hacer nada práctico sin él?"</i>, es decir, no tiene sentido que el kernel 
                    continúe funcionando <strong>sin uno de sus componentes clave corriendo</strong>. <br>
                    Eso lo resuelve el patrón monolítico. Y además me ahorra el tener que interconectar subsistemas clave entre sí con IPC, lo que impacta de una en el rendimiento del Sistema Operativo. No es
                    perfecto, pero es estable. No es del todo trazable y requiere escalar de a poco, pero si escala bien rinde mucho. <br>

                    <br>
                    Sin embargo yo también tengo desacuerdos con la <a href="https://es.wikipedia.org/wiki/Filosof%C3%ADa_de_Unix" target="_blank" rel="noopener noreferrer">filosofía UNIX</a>. Ellos (entre otras cosas y de forma resumidísima) consideran
                    que si algo falla, que falle bien. Lo que en términos kernelísticos sería: <i>Si se rompe el scheduler, Panic() directo. Si tenés corrupción en memoria (en espacio de kernel), Panic.</i><br>
                    Y no es que lo cuestiono por que sí, simplemente pregunto (aunque sin soluciones todavía) <i>"¿Por qué no rescatar el sistema en tiempo de Panic()?, o por lo menos hacer el intento"</i>. <br>
                    Mas allá del punto filosófico y para resumir, el kernel es monolítico porque es más performante y siento que las piezas clave del núcleo deben <strong>trabajar sin overhead</strong>. <br>
                    Sin embargo, si en el futuro necesitara integrar algún subsistema específico de forma híbrida, seguramente sería pragmático.
                </p>
                <h2>El Kernel Space es sagrado</h2>
                <p>
                    Yo sé que hablo como si IR0 fuera usado por miles de personas y toda la historia, pero el punto es que el kernel space es sólo habitable por subsistemas que trabajen en ese Entorno,
                    nada mas. <br> RING 0 es únicamente para el kernel. Todo lo que venga del RING 3 se comunica con <i>syscalls()</i>, fin del comunicado.
                </p>

            </div>


            <div class="info-card">
                <h2>Estructura de Directorios</h2>
                <p>
                    Cómo la estructura de archivos puede cambiar constantemente, prefiero que la consultes en el 
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank" rel="noopener noreferrer">Repo de GitHub</a>.
                </p>

            </div>

        </section>

        <section id="branches" class="section">
            <h1 class="titulo-principal">Gestión de Ramas</h1>
            <div class="info-card">
                <h2>Flujo de Trabajo con Git</h2>
                <div class="code-block">
                    <article>Como es la primera vez que escribo un proyecto de esta evergadura, lo que busco
                        es que el Workflow para el desarrollo del kernel sea
                        lo mas limpio, predecible y escalable posible. Para eso uso 3 ramas de git principales en el
                        proceso: mainline, dev y feature (que aunque no está en el repositorio, es la que se usa para
                        integrar código nuevo).
                        Donde sólo <strong>mainline</strong> y <strong>dev</strong> son las únicas 2 <i>ramas upstream</i>. <strong>experimental</strong> es una rama
                        divergente a dev y feature es la rama donde se envían contribuciones.
                    </article>
                </div>
            </div>

            <!-- mainline BRANCH -->
            <div class="branch-grid">
                <div class="branch-card">
                    <div class="branch-title">mainline</div>
                    <div class="status-badge status-stable">STABLE</div>
                    <p><strong>-</strong> Rama principal con código estable y testeado.</p>

                    <h3>Características</h3>
                    <ul class="feature-list">
                        <li>Solo código probado y funcional</li>
                        <li>Documentación completa</li>
                        <li>Mi base para rc's.</li>
                        <li>mainline es sagrada, ya que este rama tiene que compilar y bootear siempre . Es la mas
                            estable de las
                            dos ramas upstream.</li>
                    </ul>

                </div>
                <!-- DEV BRANCH -->
                <div class="branch-card">
                    <div class="branch-title">dev</div>
                    <div class="status-badge status-development">STAGING</div>
                    <p><strong>-</strong> Rama de desarrollo activo donde se implementan y testean nuevas
                        features.</p>

                    <h3>Características:</h3>
                    <ul class="feature-list">
                        <li>Es el espejo del mainline. Lo que se mergee acá no tiene porque pasar al mainline</li>
                        <li>Nuevas features en desarrollo que me convencieron de feature</li>
                        <li>Parches de código, refactors y optimizaciones</li>
                        <li>Puede contener bugs temporales que se resuelven sí o sí en esta rama.</li>
                    </ul>

                </div>

                <!-- exp BRANCH -->

                <div class="branch-card">
                    <div class="branch-title">experimental</div>
                    <div class="status-badge status-exp">MISC</div>
                    <p><strong>-</strong>
                        En esta rama, se integran features lo suficientemente inestables como para terminar en
                        <strong>mainline</strong>
                        pero que pueden tener potencial a futuro.
                    </p>

                    <h3>Características:</h3>
                    <ul class="feature-list">
                        <li>Es una rama de pruebas puras, no tiene nada que ver con las ramas upstream estables</li>
                        <li>Acá caen las features y experimentos que no llegan al <strong>mainline</strong></li>
                        <li>Cosas que no se prueban en sistemas operativos o ideas nuevas</li>
                        <li>No es tan importante la estabilidad en esta rama</li>
                        <li>Si se testean lo suficiente sin romper nada, pueden o no mergear a mainline primero
                            pasando por <strong>dev</strong> de nuevo.
                        </li>
                    </ul>
                </div>

                <!-- feat BRANCH -->
                <div class="branch-card">
                    <div class="branch-title">feature</div>
                    <div class="status-badge status-feat">DEVELOPMENT</div>
                    <p><strong>-</strong>
                        La agrego porque es la rama donde se crean feats que despues pasan al upstream
                        mergeando a <strong>dev</strong> . Es la más inestable de todas porque es donde se integra
                        código nuevo que también debe ser testeado y revisado antes de llegar a merge.
                    </p>

                    <h3>Características:</h3>
                    <ul class="feature-list">
                        <li>Acá es donde yo empiezo a implementar nuevas funcionalidades o parches</li>
                        <li>Es la primera que se debuggea</li>
                    </ul>
                </div>
            </div>
            <div class="info-card">
                <h2>Cómo es el merging desde feature hasta mainline?</h2>

                <article> 
                    Básicamente, vos creás tu mejora/optmización desde un fork del repo con una rama nueva que va a ser algo como "feature/fix-scheduler" por ej.  <br>
                    Después, <strong>hacés PR a la rama dev del upstream</strong> y se hace la revisión y el merge en dado caso. <br>
                    El merge a mainline depende de <strong>cuán alineado con el proyecto considere que es la feature</strong>. <br>
                    Ni siquiera algunas de mis propias implementaciones las mergearía directo al mainline por esta misma razón.  
                </article>

            </div>

    </div>



    </section>

    <section id="development" class="section">
        <h1 class="titulo-guia">Guía de Desarrollo</h1>

        <div class="info-card">
            <h2>Configuración del Entorno</h2>
            <h3>Dependencias Requeridas:</h3>
            <strong>-</strong> Gcc, QEMU(vm), makefile y el nasm. <br><br>
            
                <strong>Ubuntu/Debian</strong><br> 
                sudo apt update <br>
                sudo apt install gcc make nasm qemu-system-x86 gdb <br>

                <strong>Arch Linux</strong> <br>
                sudo pacman -S gcc make nasm qemu gdb
            
        </div>

        <div class="info-card">
            <h2>Compilación y Ejecución</h2>
            <div class="code-block">
                # Clonar repositorio
                git clone https://github.com/usuario/ir0-kernel.git
                cd ir0-kernel

                # Compilar kernel
                make clean
                make all

                # Ejecutar en QEMU
                make run

                # Debug con GDB
                make debug
            </div>
        </div>

        <div class="info-card">
            <h2>Cómo escribo código?</h2>
            <h3>Convenciones de Nombres:</h3>
            <ul class="feature-list">
                <li>Funciones: <code>snake_case()</code></li>
                <li>Macros: <code>UPPER_CASE</code></li>
                <li>Structs: <code>struct_name_t</code></li>
                <li>Variables globales: <code>g_variable_name</code></li>
                <li>Constantes: <code>CONSTANT_NAME</code></li>
            </ul>

            <h3>Comentarios:</h3>
            <ul class="feature-list">
                <li>Headers de funciones documentados</li>
                <li>Explicación de algoritmos complejos</li>
                <li>TODOs claramente marcados</li>
                <li>Referencias a documentación técnica</li>
            </ul>
        </div>

        <div class="info-card">
            <h2>Sistema de Testing</h2>
            <div class="code-block">
                # Tests básicos
                make test-boot <br>
                make test-memory # Test de gestión de memoria
                make test-panic # Test del sistema de panic

                # Test completo
                make test-all

                # Ejecutar con logging detallado
                make run-verbose
            </div>
        </div>
    </section>

    <section id="panic" class="section">
        <h1 class="titulo-guia">Sistema de Panic Avanzado</h1>

        <div class="info-card">
            <h2>Características del Panic Handler</h2>
            <p>El sistema de panic de IR0 proporciona información detallada para debugging cuando ocurren errores
                fatales en el kernel.</p>

            <h3>Tipos de Panic:</h3>
            <ul class="feature-list">
                <li><strong>PANIC_KERNEL_BUG:</strong> Errores en código del kernel</li>
                <li><strong>PANIC_HARDWARE_FAULT:</strong> Fallos de hardware</li>
                <li><strong>PANIC_OUT_OF_MEMORY:</strong> Sistema sin memoria</li>
                <li><strong>PANIC_STACK_OVERFLOW:</strong> Desbordamiento de pila</li>
                <li><strong>PANIC_ASSERT_FAILED:</strong> Falla de assertion</li>
            </ul>
        </div>

        <div class="info-card">
            <h2>Ejemplo de Salida de Panic</h2>
            <div class="panic-output">
                ╔═══════════════════════════════════════════════════════════╗
                ║ KERNEL PANIC ║
                ╚═══════════════════════════════════════════════════════════╝

                Type: KERNEL BUG
                Location: memory.c:245
                Message: Invalid page frame detected

                --- REGISTER DUMP ---
                EAX: 0x12345678 EBX: 0x87654321
                ECX: 0xABCDEF00 EDX: 0x11223344
                ESP: 0xC0100000 EBP: 0xC0100020
                CR0: 0x80000031 CR2: 0x00000000 CR3: 0x00101000
                EFLAGS: 0x00000202

                --- STACK TRACE ---
                #0: 0xC0101234
                #1: 0xC0102456
                #2: 0xC0103678

                --- MEMORY INFO ---
                Total memory: 33554432 bytes
                Free memory: 16777216 bytes
                Memory usage: 50%

                ═══ SYSTEM HALTED ═══
                Safe to power off or reboot
            </div>
        </div>

        <div class="info-card">
            <h2>Uso del Sistema de Panic</h2>
            <div class="code-block">
                // Panic básico
                panic("Error fatal en el kernel");

                // Panic con tipo específico
                panic_advanced("Invalid pointer", PANIC_KERNEL_BUG, __FILE__, __LINE__);

                // Macros útiles para debugging
                BUG_ON(ptr == NULL); // Panic si la condición es verdadera
                ASSERT(size > 0); // Panic si la condición es falsa

                // Verificaciones de memoria
                if (unlikely(!valid_address(addr))) {
                panic_advanced("Invalid memory address", PANIC_HARDWARE_FAULT,
                __FILE__, __LINE__);
                }
            </div>
        </div>

        <div class="info-card">
            <h2>Protección contra Double Panic</h2>
            <p>El sistema incluye protección contra situaciones donde el propio panic handler puede fallar:</p>
            <ul class="feature-list">
                <li>Detección de panic recursivo</li>
                <li>Mensaje de emergencia simplificado</li>
                <li>Halt inmediato para evitar corrupción</li>
                <li>Estado volatile para threading seguro</li>
            </ul>
        </div>
    </section>
    </div>

</body>

</html>