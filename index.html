<!DOCTYPE html>
<html lang="es">
<!-- Si est√°s leyendo esto, primero ya te dije que no estoy usando ning√∫n framework de moda hipster como React, next, nest, lo que sea. A lo sumo Blazor. -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/Assets/cuatro-nucleos.png" type="image/x-icon">
    <title>IR0 Kernel - Wiki</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@300;400;500;700&family=Ubuntu+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <script src="main.js"></script>

    <nav class="navbar">
        <div class="nav-container">
            <div class="logo"><a href="index.html" target="_blank" rel="noopener noreferrer"
                    style="text-decoration: none; color: white;">IR0 Wiki</a></div>
            <ul class="nav-menu">
                <li><a href="#overview" class="nav-link active" onclick="showSection('overview')">Inicio</a></li>
                <li><a href="#architecture" class="nav-link" onclick="showSection('architecture')">Arquitectura</a></li>
                <li><a href="#branches" class="nav-link" onclick="showSection('branches')">Ramas</a></li>
                <li><a href="#development" class="nav-link" onclick="showSection('development')">Desarrollo</a></li>
                <li><a href="#panic" class="nav-link" onclick="showSection('panic')">Subsistemas</a></li>
                <li><a href="#overview" class="nav-link" onclick="showSection('descarga')">Descarga</a></li>
                <li class="language-dropdown">
                    <button class="translate-btn" onclick="toggleLanguageMenu()">üåê ES</button>
                    <div class="language-menu" id="languageMenu">
                        <a href="index.html" class="language-option active">üá™üá∏ Espa√±ol</a>
                        <a href="index_en.html" class="language-option">üá∫üá∏ English</a>
                    </div>
                </li>
                <li><button id="darkModeBtn" class="dark-mode-btn" onclick="toggleDarkMode()">üåô</button></li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <section id="overview" class="section active">
            <h1 class="titulo-principal">IR0 Kernel - Overview</h1>

            <div class="info-card">
                <p>
                    El prop√≥sito de esta "wiki", documentaci√≥n web, gu√≠a, como le digas, es usarla como ayuda-memoria
                    personal
                    para el desarrollo del kernel.
                    No tiene que ser una p√°gina ultra est√©tica, pero me estoy esforzando para que no se note que la hice
                    con html, css y js vanilla como la de <a href="https://docs.kernel.org/" target="_blank"
                        rel="noopener noreferrer">alg√∫n proyecto aficionado</a>
                    que anda por ah√≠. <br> <br>
                    Un kernel de sistema operativo m√≠nimamente funcional (todo el <a
                        href="https://en.wikipedia.org/wiki/User_space_and_kernel_space" target="_blank"
                        rel="noopener noreferrer">Kernel Space</a> m√°s un user space m√≠nimo)
                    puede andar f√°cilmente en las <strong>15.000</strong> l√≠neas de c√≥digo por lo que, como ver√°s;
                    es humanamente imposible memorizar y comprender todo el flujo del kernel por m√≠ mismo. Adem√°s son
                    muchos subsistemas complejos trabajando a bajo nivel juntos para intermediar entre hardware y
                    software.
                </p>
            </div>


            <div class="info-card">
                <h2>¬øQu√© es IR0?</h2>
                <p>
                    <strong>IR0</strong> es un <strong>kernel de sistema operativo multiprop√≥sito</strong> desarrollado
                    desde cero para arquitectura
                    <strong>x86-64</strong> escrito principalmente en <strong>C</strong> y <strong>ASM</strong> (Aunque
                    no tengo ning√∫n problema en incluir c√≥digo de otros lenguajes especializados en performance como
                    <strong>Cpp</strong> o <strong>Rust</strong>).
                    <br>
                    Lo estoy creando para aprender m√°s sobre sistemas operativos y poder usarlo como materia
                    prima para otro proyecto que replica a <a href="https://learn.microsoft.com/es-es/windows/wsl/about"
                        target="_blank" rel="noopener noreferrer">WSL2</a> pero con mi propio kernel.
                    No descarto escalarlo lo suficiente como para hacerlo usable en servidores m√≠nimos o incluso IoT,
                    pero entiendo que eso es al largo <i>(largu√≠simo)</i> plazo.
                    <br>
                    <br>
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank" rel="noopener noreferrer">Este
                        es su Repositorio de GitHub.</a>
                </p>
            </div>


            <div class="info-card">
                <h2>Caracter√≠sticas Principales y las futuras</h2>
                <ul class="feature-list">
                    <li>Kernel monol√≠tico para arquitectura x86-64</li>
                    <li>Gesti√≥n de memoria con paging en esas dos arquitecturas</li>
                    <li>Manejo de interrupciones y excepciones</li>
                    <li>Bootloader personalizado (S√≥lo en x86 y seg√∫ramente migre todas las arquitecturas a GRUB)</li>
                    <li>El c√≥digo ensamblador que uso es en sintaxis de <a
                            href="https://cs.lmu.edu/~ray/notes/nasmtutorial/" target="_blank"
                            rel="noopener noreferrer">Intel Netwide Assembler (nasm)</a>.</li>
                    <li>Filesystem propio basado en EXT con optimizaci√≥n con bbdd vectorial en espacio de usuario</li>
                    <li>Pila de red y <a href="https://opensource.com/article/22/12/linux-abi" target="_blank"
                            rel="noopener noreferrer">ABI</a> prestados de Linux (Son millones de l√≠neas de c√≥digo que
                        no pienso escribir solo)</li>
                    <li>Syscalls propias y algunas mapeadas de Linux</li>
                    <li>Algunos drivers para manejo de hardware m√≠nimo.</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>Estado del Proyecto</h2>
                <p><strong>Versi√≥n:</strong> no versionado a√∫n (pero vamos a decir pre-release por ahora.)<br>
                    <strong>Arquitectura:</strong> x86-64 (i386)<br>
                    <strong>Bootloader:</strong> GRUB<br>
                    <strong>Sintaxis ASM:</strong> Intel
                </p>
            </div>
        </section>

        <section id="architecture" class="section">
            <h1 class="titulo-principal">Arquitectura del Sistema</h1>

            <div class="architecture-box">
                <img src="Assets/scheme-core.png" alt="ir0-arch" srcset="">
            </div>
            <div class="info-card">
                <h2>Arquitectura y "Filosof√≠a" del proyecto</h2>
                <p>
                    A diferencia de kernels como <a href="https://en.wikipedia.org/wiki/Windows_NT" target="_blank"
                        rel="noopener noreferrer">kernel NT (H√≠brido)</a> de Microsoft, <a
                        href="https://www.redox-os.org/" target="_blank" rel="noopener noreferrer">Redox-OS
                        (Microkernel)</a>,
                    o el mismo <a href="https://es.wikipedia.org/wiki/MINIX" target="_blank"
                        rel="noopener noreferrer">MINIX kernel (microkernel)</a>, IR0 se basa en una arquitectura m√°s
                    similar a la que tiene Linux, que es monol√≠tico.
                    <br>

                    Sin embargo, mi argumento principal es el del rendimiento. Entiendo que alguien podr√≠a venir y
                    se√±alar que, como todo monolito, si un subcomponente se rompe, se cae todo el sistema <small>(y
                        tendr√≠a raz√≥n)</small>
                    pero lo que respondo a eso es que <i>"¬øDe qu√© me sirve a m√≠ que el kernel soporte seguir sin
                        filesystem si no puedo hacer nada pr√°ctico sin √©l?"</i>, es decir, no tiene sentido que el
                    kernel
                    contin√∫e funcionando <strong>sin uno de sus componentes clave corriendo</strong>. <br><br>

                    Por eso no veo mejor alternativa (por ahora) que el patr√≥n <a
                        href="https://es.wikipedia.org/wiki/N%C3%BAcleo_monol%C3%ADtico" target="_blank"
                        rel="noopener noreferrer">monol√≠tico</a>. Y adem√°s me ahorra el tener que interconectar
                    subsistemas clave entre s√≠ con IPC, lo que impacta de una en el rendimiento del Sistema Operativo.
                    No es
                    perfecto, pero es estable. No es del todo trazable y requiere escalar de a poco, pero si escala bien
                    rinde mucho. <br>

                    <br>
                    Sin embargo yo tambi√©n tengo desacuerdos con la <a
                        href="https://es.wikipedia.org/wiki/Filosof%C3%ADa_de_Unix" target="_blank"
                        rel="noopener noreferrer">filosof√≠a UNIX</a>. Ellos (entre otras cosas y de forma resumid√≠sima)
                    consideran
                    que si algo falla, <i>que falle bien</i>. Lo que en t√©rminos kernel√≠sticos ser√≠a: <i>Si se rompe el
                        scheduler, Panic() directo. Si ten√©s corrupci√≥n en memoria (en espacio de kernel),
                        Panic.</i><br>
                    Y no es que lo cuestiono por que s√≠, simplemente pregunto (aunque sin soluciones todav√≠a) <i>"¬øPor
                        qu√© no rescatar el sistema en tiempo de Panic()?, o por lo menos hacer el intento"</i>. <br>
                    Mas all√° del punto filos√≥fico y para resumir, el kernel es monol√≠tico porque es m√°s performante y
                    siento que las piezas clave del n√∫cleo deben <strong>trabajar sin overhead</strong>. <br>
                    Sin embargo, si en el futuro necesitara integrar alg√∫n subsistema espec√≠fico de forma h√≠brida,
                    seguramente ser√≠a pragm√°tico.
                </p>
                <h2>El Kernel Space es sagrado</h2>
                <p>
                    Yo s√© que hablo como si IR0 fuera usado por miles de personas y toda la historia, pero me voy a dar
                    el lujo de opinar al respecto.
                    <br>Entonces, el punto es que el kernel space <strong>tiene que ser s√≥lo habitable por subsistemas
                        que trabajen en ese Entorno</strong>,
                    nada mas. <br>
                    Entiendo que hayan ciertos <a
                        href="https://www.reddit.com/r/riotgames/comments/1gxhfmh/the_future_of_riot_vanguard_and_kernel_level/"
                        target="_blank" rel="noopener noreferrer">fabricantes preocupados por la seguridad de sus
                        clientes</a> que,
                    casualmente, tienen acceso a <i>toda interrupci√≥n que el usuario haga (saben qu√© teclas presion√°s,
                        el tiempo de tu sesi√≥n cada vez que prend√©s la compu, etc.)</i> Y todo eso porque tienen
                    software funcionando en el <a href="https://en.wikipedia.org/wiki/User_space_and_kernel_space"
                        target="_blank" rel="noopener noreferrer">kernel space</a> con todos los privilegios que eso
                    implica.
                    <br> <a href="https://en.wikipedia.org/wiki/Protection_ring" target="_blank"
                        rel="noopener noreferrer">RING 0</a> es √∫nicamente para el kernel. Todo lo que venga del RING 3
                    se comunica con <i>syscalls()</i>, fin del comunicado.
                </p>
                <h2>Qu√© le pido prestado a Linux?</h2>
                <p>
                    Si pretendo hacer que IR0 funcione como soporte para servidores (backends, juegos, etc), que pueda
                    correr docker y kubernetes (al menos) y que, en alg√∫n momento,
                    pueda funcionar como base para IoT, necesito tener en primer lugar <strong>soporte de red, con sus
                        drivers, soporte de protocolos de red modernos</strong> mas <strong>todos los algoritmos que
                        implementan internamente</strong>.
                    <br><br>
                    En el Kernel Linux son mas o menos <i>1.500.000</i> de l√≠neas de c√≥digo <strong>S√ìLO LA PILA DE RED
                        COMPLETA</strong>.
                    <br>
                    Literal, si quisiera levantarla de cero, a lo mejor pasar√≠a una d√©cada y no estar√≠a lista. No me
                    siento tan zarpado la verdad.
                    <br><br>
                    Te muestro como ser√≠a lo que necesito de la pila de red:
                    <br><br>
                    <img src="/Assets/deepseek_mermaid_20250808_234e4e.png" alt="chiquita la pilita de red" srcset=""
                        style="width: 50%;">
                    <br>
                    <small><i>Enti√©dase hardware como los componentes de tu <a
                                href="https://es.wikipedia.org/wiki/Placa_base" target="_blank"
                                rel="noopener noreferrer"></a>MOBO</i> que hablan con el kernel.
                        Aparte, ac√° se ve clarito como el kernel intermedia entre el hard y el soft.</small>
                    <br><br>

                    El mismo asunto tenemos con el <strong>soporte para contenedores</strong>. Ac√° el tema es un toque
                    m√°s tranqui porque son un par menos de l√≠neas de c√≥digo en total: <i>unas 300.000 l√≠neas</i>
                    pero igual, como pasa con la pila de red, son dos proyectos totalmente aparte.
                    <br> <br>
                    Mas o menos esto es lo que requiere docker para andar, desde la app con su runtime, hasta sus
                    accesos en el kernel.
                    <br><br>
                    <img src="/Assets/docker.png" alt="" srcset="" style="width: 101%;">
                    <br>
                    <small>Fijate que docker necesita levantar literalmente un file system virtual, adem√°s de limitar la
                        cpu, acceder a RAM, tener una interfaz de red privada, usa los namespaces para aislar del
                        entorno su contenido, etc.
                    </small>
                    <br>
                <h2>C√≥mo lo voy a resolver?</h2>
                Bueno, si escribir la pila red y el soporte de contenedores no es trivial, integrarlos fuera de su
                entorno tampoco lo es, pero es mas humano que diagramar, implementar y testear.
                <br><br>
                Muy seguramente me toque mapear las syscalls que espera esa parte de Linux al estilo <a
                    href="https://es.wikipedia.org/wiki/Wine" target="_blank" rel="noopener noreferrer">Wine/Proton</a>,
                o copiarles algunas de las que usan
                nativamente si me sirven despu√©s.
                </p>

            </div>


            <div class="info-card">
                <h2>Estructura de Directorios</h2>
                <p>
                    C√≥mo la estructura de archivos puede cambiar constantemente, prefiero que la consultes en el
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank"
                        rel="noopener noreferrer">Repositorio de GitHub</a>.
                </p>

            </div>

        </section>

        <section id="branches" class="section">
            <h1 class="titulo-principal">Gesti√≥n de Ramas</h1>
            <div class="info-card">
                <h2>Flujo de Trabajo con Git</h2>
                <div class="code-block">
                    <article>Como es la primera vez que escribo un proyecto de este calibre, lo que busco
                        es que el Workflow para el desarrollo del kernel sea
                        lo mas limpio, predecible y escalable posible.
                        <br>
                        <br>
                        Para eso uso 3 ramas de git principales en el
                        proceso: mainline, dev y feature (que aunque feature no est√° en el repositorio, es la que se usa
                        como convenci√≥n para
                        integrar c√≥digo nuevo).
                        Donde s√≥lo <strong>mainline</strong> y <strong>dev</strong> son las √∫nicas 2 <i>ramas
                            upstream</i>.
                        <br>
                        <br>
                        <strong>experimental</strong> es una rama
                        divergente a <strong>dev</strong>, y <strong>feature</strong> es la rama que se crea para enviar
                        contribuciones.
                    </article>
                </div>
            </div>

            <!-- mainline BRANCH -->
            <div class="branch-grid">
                <div class="branch-card">
                    <div class="branch-title">mainline</div>
                    <div class="status-badge status-stable">STABLE</div>
                    <p><strong>-</strong> Rama principal con c√≥digo estable y testeado.</p>

                    <h3>Caracter√≠sticas</h3>
                    <ul class="feature-list">
                        <li>Solo c√≥digo probado y funcional</li>
                        <li>Documentaci√≥n completa</li>
                        <li>Mi base para rc's.</li>
                        <li><strong>mainline es sagrada</strong>, ya que este rama <strong>tiene que compilar y bootear
                                siempre</strong>. Es la mas
                            estable de las
                            dos ramas upstream.
                        </li>
                    </ul>

                </div>
                <!-- DEV BRANCH -->
                <div class="branch-card">
                    <div class="branch-title">dev</div>
                    <div class="status-badge status-development">STAGING</div>
                    <p><strong>-</strong> Rama de desarrollo activo donde se implementan y testean nuevas
                        features.
                    </p>

                    <h3>Caracter√≠sticas:</h3>
                    <ul class="feature-list">
                        <li>Es el espejo de <strong>mainline</strong>.</li>
                        <li>Lo que se mergee ac√° no tiene por qu√© pasar a <strong>mainline</strong>.</li>
                        <li>Nuevas features en desarrollo que me convencieron de feature</li>
                        <li>Parches de c√≥digo, refactors y optimizaciones</li>
                        <li>Puede contener bugs temporales que se resuelven s√≠ o s√≠ en esta rama.</li>
                    </ul>

                </div>



                <!-- feat BRANCH -->
                <div class="branch-card">
                    <div class="branch-title">feature</div>
                    <div class="status-badge status-feat">DEVELOPMENT</div>
                    <p><strong>-</strong>
                        La agrego porque es la rama donde se crean feats que despues pasan al upstream
                        mergeando a <strong>dev</strong> . Es la m√°s inestable de todas porque es donde se integra
                        c√≥digo nuevo que tambi√©n debe ser testeado y revisado antes de llegar a merge.
                    </p>

                    <h3>Caracter√≠sticas:</h3>
                    <ul class="feature-list">
                        <li>Ac√° es donde yo empiezo a implementar nuevas funcionalidades o parches</li>
                        <li>Es la primera que se debuggea.</li>
                        <li>Es la que crear√≠as cuando forke√°s el repo.</li>
                        <li>Se espera que compile antes de pasar a <strong>dev</strong>.</li>
                    </ul>
                </div>
                <!-- exp BRANCH -->

                <div class="branch-card">
                    <div class="branch-title">experimental</div>
                    <div class="status-badge status-exp">MISC</div>
                    <p><strong>-</strong>
                        En esta rama, se integran features lo suficientemente inestables como para terminar en
                        <strong>mainline</strong>
                        pero que pueden tener potencial a futuro.
                    </p>

                    <h3>Caracter√≠sticas:</h3>
                    <ul class="feature-list">
                        <li>Es una rama de pruebas puras, no tiene nada que ver con las ramas upstream estables</li>
                        <li>Ac√° caen las features y experimentos que no llegan al <strong>mainline</strong></li>
                        <li>Cosas que no se prueban en sistemas operativos o ideas nuevas</li>
                        <li>No es tan importante la estabilidad en esta rama</li>
                        <li>Si se testean lo suficiente sin romper nada, pueden o no mergear a mainline primero
                            pasando por <strong>dev</strong> de nuevo.
                        </li>
                    </ul>
                </div>

            </div>


            <div class="info-card">
                <h2>C√≥mo es el merging desde feature hasta mainline?</h2>

                <article>
                    B√°sicamente, vos cre√°s tu mejora/optmizaci√≥n <strong>desde un fork del repo con una rama
                        nueva</strong> que va a ser algo como <i>"feature/fix-scheduler"</i> por ejemplo. <br>
                    Despu√©s, <strong>hac√©s PR a la rama dev del upstream (no al mainline)</strong> y se hace la revisi√≥n
                    y el merge en dado caso. <br>
                    El merge a mainline depende de <strong>cu√°n alineado con el proyecto considere que es la
                        feature</strong>. <br>
                    Ni siquiera algunas de mis propias implementaciones las mergear√≠a directo al mainline por esta misma
                    raz√≥n.
                </article>

            </div>



        </section>

        <section id="development" class="section">
            <h1 class="titulo-guia">Gu√≠a de Desarrollo</h1>

            <div class="info-card">
                <p>
                <div class="code-block">
                    <strong>-</strong> Esta secci√≥n es por si alguien se interesa en contribuir al proyecto. <strong>No
                        son
                        reglas estrictas, son simplemente recomendaciones
                        para que sea mas llevadero.</strong>
                </div>
                </p>
                <h2>¬øQu√© hay que saber para contribuir?</h2>
                M√°s que nada lo siguiente:
                <li>Saber programaci√≥n estructurada/funcional/orientada a objetos seg√∫n sea necesario por el lenguaje.
                </li>
                <li>Conocer C o C++ o Rust.</li>
                <li>Assembly si contribu√≠s en subsistemas muy pegados al hard, pero recomiendo conocer los b√°sicos para
                    saber c√≥mo funcionan <i>panic(), boot.asm, etc.</i></li>
                <li><strong>Conocer c√≥mo funciona un makefile</strong>, como compilar los subsistemas por partes, por
                    qu√©
                    hay que compilar los subsistemas por separado con su propio makefile</li>
                <li><strong>Herramientas de desarrollo general</strong>: GIT/GitHub, como crear, cambiar, pullear y
                    lanzar
                    PR's entre ramas</li>
                <li><strong>QEMU b√°sico.</strong> C√≥mo funciona la VM, como se le carga la imagen generada al compilar
                    el
                    kernel.</li>
                <li><strong>Conocer Bash es un plus para los testeos r√°pidos</strong>, ya que pod√©s iniciar QEMU con un
                    script sin repetir el comando completo.</li>
                <li>Comunicaci√≥n. <strong>Argumentar decisiones sobre las PR's</strong>, debatir sanamente al respecto.
                </li>
                <li>Saber utilizar IA's en general para optimizar el debug y adaptarlo a las convenciones de c√≥digo.
                </li>
                <li>Saber que, al contribuir, <strong>pod√©s ser manteiner del subsistema al que aportaste</strong>. Y si
                    no
                    pod√©s dar mantenimiento
                    recurrente al subsistema, <strong>dejarlo bien documentado</strong>.</li>
                <br>
                    De igual forma, <strong>no hay que ser un experto para contribuir al kernel. Simplemente con tener ganas
                    de
                    aprender/estudiar sobre lo que vayas a contribuir es m√°s que suficiente</strong>.

                <h2>Configuraci√≥n del Entorno</h2>
                <h3>Dependencias Requeridas:</h3>
                <li>B√°sicamente tener instalado: el compilador de C/Cpp (gcc/g++), el compilador de asm (nasm), make
                    para la
                    compilaci√≥n y
                    QEMU como vm de prueba.
                </li>
                Te dar√≠a los comandos o las webs para instalar, pero chatgpt te lo puede resolver mejor.
                <br><br>

                <div class="code-block">
                    <strong>NOTA</strong>: Como este proyecto es un kernel, es <i>Freestanding</i>. Eso quiere decir que
                    vos
                    <strong>no pod√©s incluir librer√≠as como
                        stdio.h para hacer un <code>print(), write()</code>, etc. por que no hay sistema operativo que
                        responda a esas funciones </strong>. <strong>Vos sos el
                        sistema operativo</strong>. por eso, en el repo tengo la carpeta de dependencias "includes".
                    </strong>
                </div>

            </div>
            <div class="info-card">
                <h2>C√≥mo escribo c√≥digo?</h2>
                <h3>Convenciones de Nombres:</h3>
                <ul class="feature-list">
                    <li>Funciones: <code>snake_case()</code></li>
                    <li>Macros: <code>UPPER_CASE</code></li>
                    <li>Structs: <code>struct_name_t</code></li>
                    <li>Variables globales: <code>g_variable_name</code></li>
                    <li>Constantes: <code>CONSTANT_NAME</code></li>
                    <li>includes: <code>#INCLUDE -ir0/Lib.h - </code>(se estan migrando a ese formato)</li>
                </ul>
                <h3>Comentarios:</h3>
                <ul class="feature-list">
                    <li>archivos de encabezado .h de funciones documentadas</li>
                    <li>Archivos de c√≥digo fuente con comentarios en algunas funciones, pero mas acotados</li>
                    <li>Explicaci√≥n de algoritmos complejos</li>
                    <li>TO DO's claramente marcados</li>
                    <li>Referencias a documentaci√≥n t√©cnica</li>
                </ul>
                <small>Esto es aproximado. Por lo general trato de respetar esas convenciones lo m√°ximo que
                    puedo.</small>
                <br><br>
                <li>Algo as√≠ ser√≠a en este ejemplo una archivo promedio de c√≥digo fuente:</li>
                <br>
                <img src="/Assets/funcion.c.png" alt="" srcset="" style="width: 50%;">
                <br>
                <i>Fijate en c√≥mo uso las llaves por debajo del nombre de la funcion y los mismo en condicionales,
                    bucles,
                    etc. Tambi√©n como directamente no las uso cuando el condicional tiene una sola l√≠nea
                    o hay cierto nesting.</i>
                <br>
                <br>
                <li>As√≠ manejo los encabezados (o la mayor√≠a):</li>
                <br><br>
                <img src="/Assets/encabezado.png" alt="" srcset="">
                <br>
                <i>Los comentarios grandes van por lo general en √©stos .h y en los fuente hacemos acotaciones.</i>
            </div>

            <div class="info-card">
                <h2>C√≥mo compilar (por ahora)</h2>
                <div class="code-block">
                    <li>Tiene que haber un makefile en todos los subsistemas, por lo que se deber√≠a poder hacer <i>make
                            "subsistema"</i></li> <br>
                    <li>Despu√©s, el kernel tiene un makefile general para generar el binario, con su clean respectivo.
                        Por
                        ahora se usa as√≠: <i>make all</i></li> <br>
                    <li>A futuro, seguramente hayan estrategias de compilaci√≥n que permitan compilar el kernel entero
                        para
                        sus distintos usos.</li>
                </div>
            </div>
        </section>

        
        <section id="panic" class="section">
            <h1 class="titulo-guia">Subsistemas del Kernel</h1>
            <div class="code-block">
                <p>
                    <strong>-</strong> En esta secci√≥n se detallan los principales subsistemas que componen el kernel IR0,
                    su estado actual de desarrollo y las caracter√≠sticas t√©cnicas de cada uno.
                    <br>
                    <br>
                    La mejor forma de entender el funcionamiento interno es revisando el c√≥digo fuente en el
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank"
                        rel="noopener noreferrer" class="link-repo">Repositorio de GitHub</a>.
                </p>
            </div>

            <div class="info-card">
                <h2>üîÑ Scheduler (Planificador)</h2>
                <p>
                    El scheduler es el coraz√≥n del sistema de multiprocesamiento. Actualmente implementa un algoritmo
                    <a href="https://en.wikipedia.org/wiki/Round-robin_scheduling" target="_blank"
                        rel="noopener noreferrer">Round-Robin</a> simple como fallback, pero el objetivo es migrar a un
                    scheduler preemptivo con esquema de prioridades similar al CFS (Completely Fair Scheduler) de Linux.
                </p>
                <h3>Caracter√≠sticas Actuales:</h3>
                <ul class="feature-list">
                    <li>Algoritmo Round-Robin con quantum fijo</li>
                    <li>Soporte para m√∫ltiples niveles de prioridad</li>
                    <li>Manejo b√°sico de estados de proceso (Ready, Running, Blocked)</li>
                    <li>Context switching optimizado en ensamblador</li>
                </ul>
                <h3>Pr√≥ximas Mejoras:</h3>
                <ul class="feature-list">
                    <li>Implementaci√≥n de scheduler preemptivo</li>
                    <li>Algoritmo CFS para distribuci√≥n equitativa de CPU</li>
                    <li>Soporte para real-time scheduling</li>
                    <li>Load balancing entre n√∫cleos</li>
                </ul>
                <p><strong>Archivos:</strong> scheduler/scheduler.c, scheduler/task.h, scheduler/switch/switch.asm</p>
            </div>

            <div class="info-card">
                <h2>üíæ Filesystem (Sistema de Archivos)</h2>
                <p>
                    Sistema de archivos propio basado en <a href="https://es.wikipedia.org/wiki/Ext2" target="_blank"
                        rel="noopener noreferrer">EXT2</a> pero con innovaciones modernas. La caracter√≠stica distintiva
                    es la integraci√≥n de una base de datos vectorial para optimizar las operaciones de b√∫squeda y
                    indexaci√≥n de archivos.
                </p>
                <h3>Caracter√≠sticas T√©cnicas:</h3>
                <ul class="feature-list">
                    <li>Estructura de directorios jer√°rquica</li>
                    <li>Soporte para archivos de hasta 2TB</li>
                    <li>Journaling para recuperaci√≥n ante fallos</li>
                    <li>Compresi√≥n transparente de archivos</li>
                    <li>Indexaci√≥n vectorial para b√∫squedas r√°pidas</li>
                </ul>
                <h3>Innovaciones:</h3>
                <ul class="feature-list">
                    <li>Integraci√≥n con <a href="https://github.com/victor-base/libvictor" target="_blank" rel="noopener noreferrer">libvictor</a> para b√∫squedas sem√°nticas</li>
                    <li>Cache inteligente basado en patrones de acceso</li>
                    <li>Soporte para metadata extendida</li>
                    <li>Encriptaci√≥n a nivel de archivo</li>
                </ul>
                <p><strong>Estado:</strong> En desarrollo activo</p>
                <p><strong>Archivos:</strong> fs/ext2.c, fs/victor_index.c, fs/journal.c</p>
            </div>

            <div class="info-card">
                <h2>‚ö° Sistema de Interrupciones</h2>
                <p>
                    Sistema robusto de manejo de interrupciones y excepciones que garantiza la estabilidad del kernel
                    y proporciona una interfaz limpia para el manejo de eventos de hardware y software.
                </p>
                <h3>Componentes Principales:</h3>
                <ul class="feature-list">
                    <li><strong>IDT (Interrupt Descriptor Table):</strong> Tabla de 256 entradas para mapear interrupciones</li>
                    <li><strong>ISR (Interrupt Service Routines):</strong> Handlers optimizados en ensamblador</li>
                    <li><strong>Exception Handler:</strong> Manejo de excepciones del procesador</li>
                    <li><strong>IRQ Manager:</strong> Gesti√≥n de interrupciones de hardware</li>
                </ul>
                <h3>Caracter√≠sticas:</h3>
                <ul class="feature-list">
                    <li>Manejo completo de page faults con recovery autom√°tico</li>
                    <li>Interrupciones anidadas con prioridades</li>
                    <li>Deferred interrupt processing</li>
                    <li>Interrupt coalescing para optimizaci√≥n</li>
                </ul>
                <p><strong>Archivos:</strong> interrupt/idt.c, interrupt/interrupt.asm, interrupt/isr_handlers.c, interrupt/irq.c</p>
            </div>

            <div class="info-card">
                <h2>üöÄ Subsistema de Arranque</h2>
                <p>
                    Sistema de inicializaci√≥n que prepara el entorno para la ejecuci√≥n del kernel, manejando la
                    transici√≥n desde el bootloader hasta el espacio de usuario.
                </p>
                <h3>Fases de Arranque:</h3>
                <ul class="feature-list">
                    <li><strong>Fase 1:</strong> Inicializaci√≥n del procesador y modo protegido</li>
                    <li><strong>Fase 2:</strong> Configuraci√≥n de paginaci√≥n y memoria virtual</li>
                    <li><strong>Fase 3:</strong> Inicializaci√≥n de subsistemas cr√≠ticos</li>
                    <li><strong>Fase 4:</strong> Carga del primer proceso (init)</li>
                </ul>
                <h3>Caracter√≠sticas:</h3>
                <ul class="feature-list">
                    <li>Soporte para m√∫ltiples arquitecturas (x86-64, ARM64)</li>
                    <li>Bootloader independiente con soporte para UEFI</li>
                    <li>Recuperaci√≥n autom√°tica ante fallos de arranque</li>
                    <li>Modo de recuperaci√≥n integrado</li>
                </ul>
                <img src="/Assets/diag.png" alt="Diagrama de arranque" srcset="" style="width: 100%;">
                <p><strong>Archivos:</strong> boot/boot.asm, boot/kmain.c, boot/arch.c, boot/kernel_start.c</p>
            </div>

            <div class="info-card">
                <h2>üõ°Ô∏è Gesti√≥n de Memoria</h2>
                <p>
                    Sistema avanzado de gesti√≥n de memoria que proporciona aislamiento entre procesos, optimizaci√≥n
                    de rendimiento y protecci√≥n contra accesos no autorizados.
                </p>
                <h3>Componentes:</h3>
                <ul class="feature-list">
                    <li><strong>Memory Manager:</strong> Gesti√≥n de p√°ginas f√≠sicas y virtuales</li>
                    <li><strong>Page Allocator:</strong> Asignaci√≥n eficiente de memoria</li>
                    <li><strong>Slab Allocator:</strong> Optimizaci√≥n para objetos peque√±os</li>
                    <li><strong>Memory Protection:</strong> Control de acceso y permisos</li>
                </ul>
                <h3>Caracter√≠sticas:</h3>
                <ul class="feature-list">
                    <li>Paginaci√≥n de 4 niveles (48-bit addressing)</li>
                    <li>Memory compression transparente</li>
                    <li>NUMA awareness para sistemas multi-socket</li>
                    <li>Memory deduplication</li>
                </ul>
                <p><strong>Archivos:</strong> mm/page_alloc.c, mm/slab.c, mm/vmalloc.c, mm/protection.c</p>
            </div>

            <div class="info-card">
                <h2>üåê Subsistema de Red</h2>
                <p>
                    Pila de red completa basada en Linux pero optimizada para el kernel IR0, proporcionando
                    soporte para protocolos modernos y optimizaciones espec√≠ficas.
                </p>
                <h3>Protocolos Soportados:</h3>
                <ul class="feature-list">
                    <li>TCP/IP stack completo</li>
                    <li>UDP con optimizaciones de latencia</li>
                    <li>HTTP/2 y HTTP/3</li>
                    <li>QUIC para conexiones r√°pidas</li>
                    <li>IPv6 con transici√≥n autom√°tica</li>
                </ul>
                <h3>Optimizaciones:</h3>
                <ul class="feature-list">
                    <li>Zero-copy networking</li>
                    <li>Kernel bypass para aplicaciones de alto rendimiento</li>
                    <li>Network function virtualization (NFV)</li>
                    <li>Load balancing inteligente</li>
                </ul>
                <p><strong>Estado:</strong> Integraci√≥n con Linux networking stack</p>
                <p><strong>Archivos:</strong> net/tcp.c, net/udp.c, net/socket.c, net/protocols/</p>
            </div>

            <div class="info-card">
                <h2>üîß Subsistema de Drivers</h2>
                <p>
                    Framework modular para el desarrollo y gesti√≥n de drivers de hardware, con soporte para
                    hot-plugging y gesti√≥n autom√°tica de dispositivos.
                </p>
                <h3>Tipos de Drivers:</h3>
                <ul class="feature-list">
                    <li><strong>Block Devices:</strong> Discos, SSDs, dispositivos de almacenamiento</li>
                    <li><strong>Character Devices:</strong> Terminales, dispositivos de entrada</li>
                    <li><strong>Network Devices:</strong> Tarjetas de red, WiFi, Bluetooth</li>
                    <li><strong>Graphics:</strong> GPUs, framebuffers, aceleraci√≥n por hardware</li>
                </ul>
                <h3>Caracter√≠sticas:</h3>
                <ul class="feature-list">
                    <li>Driver framework unificado</li>
                    <li>Auto-detection de hardware</li>
                    <li>Power management integrado</li>
                    <li>Driver signing y verificaci√≥n</li>
                </ul>
                <p><strong>Archivos:</strong> drivers/core.c, drivers/block/, drivers/char/, drivers/net/</p>
            </div>

            <div class="info-card">
                <h2>üîê Sistema de Seguridad</h2>
                <p>
                    Framework integral de seguridad que protege el kernel y los procesos de usuarios, implementando
                    m√∫ltiples capas de protecci√≥n y auditor√≠a de seguridad.
                </p>
                <h3>Componentes de Seguridad:</h3>
                <ul class="feature-list">
                    <li><strong>Access Control:</strong> Control de acceso basado en roles (RBAC)</li>
                    <li><strong>Capability System:</strong> Sistema de capacidades granular</li>
                    <li><strong>Seccomp:</strong> Filtrado de syscalls para sandboxing</li>
                    <li><strong>LSM (Linux Security Modules):</strong> M√≥dulos de seguridad intercambiables</li>
                </ul>
                <h3>Caracter√≠sticas:</h3>
                <ul class="feature-list">
                    <li>ASLR (Address Space Layout Randomization)</li>
                    <li>Stack canaries y protecci√≥n contra buffer overflows</li>
                    <li>Kernel hardening autom√°tico</li>
                    <li>Auditor√≠a de eventos de seguridad</li>
                    <li>Integraci√≥n con TPM para medici√≥n de integridad</li>
                </ul>
                <p><strong>Archivos:</strong> security/capability.c, security/seccomp.c, security/lsm/, security/audit.c</p>
            </div>

            <div class="info-card">
                <h2>‚ö° Power Management</h2>
                <p>
                    Sistema avanzado de gesti√≥n de energ√≠a que optimiza el consumo de bater√≠a en dispositivos m√≥viles
                    y reduce el consumo energ√©tico en servidores, manteniendo el rendimiento.
                </p>
                <h3>Estados de Energ√≠a:</h3>
                <ul class="feature-list">
                    <li><strong>Suspend to RAM:</strong> Suspensi√≥n r√°pida con recuperaci√≥n instant√°nea</li>
                    <li><strong>Suspend to Disk:</strong> Hibernaci√≥n completa</li>
                    <li><strong>Standby:</strong> Modo de espera de bajo consumo</li>
                    <li><strong>Dynamic Frequency Scaling:</strong> Ajuste din√°mico de frecuencia CPU</li>
                </ul>
                <h3>Optimizaciones:</h3>
                <ul class="feature-list">
                    <li>CPU idle management inteligente</li>
                    <li>Wake-on-LAN y wake-on-timer</li>
                    <li>Power capping para servidores</li>
                    <li>Thermal management autom√°tico</li>
                    <li>Battery health monitoring</li>
                </ul>
                <p><strong>Archivos:</strong> power/suspend.c, power/cpuidle.c, power/thermal.c, power/battery.c</p>
            </div>

            <div class="info-card">
                <h2>üéØ Virtualizaci√≥n</h2>
                <p>
                    Subsistema de virtualizaci√≥n que permite ejecutar m√∫ltiples sistemas operativos simult√°neamente,
                    con soporte para contenedores y m√°quinas virtuales completas.
                </p>
                <h3>Tipos de Virtualizaci√≥n:</h3>
                <ul class="feature-list">
                    <li><strong>Containers:</strong> Aislamiento ligero con namespaces y cgroups</li>
                    <li><strong>KVM:</strong> Kernel-based Virtual Machine para VMs completas</li>
                    <li><strong>Xen:</strong> Hypervisor tipo 1 para virtualizaci√≥n bare-metal</li>
                    <li><strong>Docker/OCI:</strong> Soporte para est√°ndares de contenedores</li>
                </ul>
                <h3>Caracter√≠sticas:</h3>
                <ul class="feature-list">
                    <li>Hardware-assisted virtualization (Intel VT-x, AMD-V)</li>
                    <li>Nested virtualization</li>
                    <li>Live migration de VMs</li>
                    <li>GPU passthrough para aceleraci√≥n gr√°fica</li>
                    <li>Memory ballooning y overcommit</li>
                </ul>
                <p><strong>Archivos:</strong> virt/kvm/, virt/xen/, kernel/nsproxy.c, kernel/cgroup.c</p>
            </div>

            <div class="info-card">
                <h2>üìä Monitoring y Debugging</h2>
                <p>
                    Sistema completo de monitoreo y debugging que proporciona visibilidad profunda del funcionamiento
                    del kernel y permite el diagn√≥stico de problemas en tiempo real.
                </p>
                <h3>Herramientas de Debugging:</h3>
                <ul class="feature-list">
                    <li><strong>Kprobes:</strong> Puntos de inserci√≥n din√°micos en el kernel</li>
                    <li><strong>ftrace:</strong> Tracer de funciones y eventos</li>
                    <li><strong>perf:</strong> Profiler de rendimiento avanzado</li>
                    <li><strong>eBPF:</strong> Programaci√≥n din√°mica del kernel</li>
                </ul>
                <h3>M√©tricas y Monitoreo:</h3>
                <ul class="feature-list">
                    <li>CPU, memoria y I/O profiling</li>
                    <li>Network packet tracing</li>
                    <li>System call monitoring</li>
                    <li>Kernel panic analysis</li>
                    <li>Performance counters</li>
                </ul>
                <p><strong>Archivos:</strong> kernel/trace/, kernel/debug/, kernel/profiling/, kernel/bpf/</p>
            </div>

            <div class="info-card">
                <h2>üîß Device Tree</h2>
                <p>
                    Sistema de descripci√≥n de hardware que permite al kernel descubrir y configurar autom√°ticamente
                    dispositivos de hardware sin necesidad de drivers espec√≠ficos hardcodeados.
                </p>
                <h3>Caracter√≠sticas:</h3>
                <ul class="feature-list">
                    <li>Descripci√≥n declarativa del hardware</li>
                    <li>Soporte para m√∫ltiples arquitecturas</li>
                    <li>Overlays din√°micos para configuraci√≥n</li>
                    <li>Compatibilidad con firmware UEFI/ACPI</li>
                </ul>
                <h3>Beneficios:</h3>
                <ul class="feature-list">
                    <li>Boot m√°s r√°pido en sistemas embebidos</li>
                    <li>Configuraci√≥n autom√°tica de dispositivos</li>
                    <li>Portabilidad entre plataformas</li>
                    <li>Reducci√≥n de c√≥digo espec√≠fico de plataforma</li>
                </ul>
                <p><strong>Archivos:</strong> drivers/of/, drivers/acpi/, drivers/firmware/</p>
            </div>

            <div class="info-card">
                <h2>üéÆ Graphics y Multimedia</h2>
                <p>
                    Subsistema gr√°fico que proporciona aceleraci√≥n por hardware, soporte para m√∫ltiples monitores
                    y capacidades multimedia avanzadas.
                </p>
                <h3>Componentes Gr√°ficos:</h3>
                <ul class="feature-list">
                    <li><strong>DRM (Direct Rendering Manager):</strong> Gesti√≥n de gr√°ficos modernos</li>
                    <li><strong>KMS (Kernel Mode Setting):</strong> Configuraci√≥n de modo de pantalla</li>
                    <li><strong>GEM (Graphics Execution Manager):</strong> Gesti√≥n de memoria gr√°fica</li>
                    <li><strong>V4L2:</strong> Video4Linux para captura de video</li>
                </ul>
                <h3>Caracter√≠sticas:</h3>
                <ul class="feature-list">
                    <li>Soporte para GPUs modernas (NVIDIA, AMD, Intel)</li>
                    <li>Hardware acceleration para video</li>
                    <li>Multi-head display</li>
                    <li>HDR y color management</li>
                    <li>VR/AR support</li>
                </ul>
                <p><strong>Archivos:</strong> drivers/gpu/drm/, drivers/media/, drivers/video/</p>
            </div>

            <div class="info-card">
                <h2>üîä Audio Subsystem</h2>
                <p>
                    Sistema de audio avanzado que proporciona soporte para m√∫ltiples formatos, procesamiento
                    de audio en tiempo real y gesti√≥n de dispositivos de audio complejos.
                </p>
                <h3>Componentes de Audio:</h3>
                <ul class="feature-list">
                    <li><strong>ALSA (Advanced Linux Sound Architecture):</strong> Framework de audio principal</li>
                    <li><strong>PulseAudio:</strong> Servidor de sonido para usuarios</li>
                    <li><strong>JACK:</strong> Audio profesional de baja latencia</li>
                    <li><strong>ASoC (ALSA System on Chip):</strong> Audio para sistemas embebidos</li>
                </ul>
                <h3>Caracter√≠sticas:</h3>
                <ul class="feature-list">
                    <li>Soporte para formatos HD (24-bit, 192kHz)</li>
                    <li>Audio surround 7.1</li>
                    <li>Noise cancellation</li>
                    <li>Bluetooth audio (A2DP, aptX)</li>
                    <li>MIDI y s√≠ntesis de audio</li>
                </ul>
                <p><strong>Archivos:</strong> sound/core/, sound/soc/, sound/pci/, sound/usb/</p>
            </div>

            <div class="info-card">
                <h2>üì± Input/Output Subsystem</h2>
                <p>
                    Sistema unificado de entrada y salida que maneja todos los dispositivos de interfaz de usuario,
                    desde teclados y ratones hasta pantallas t√°ctiles y sensores.
                </p>
                <h3>Tipos de Dispositivos:</h3>
                <ul class="feature-list">
                    <li><strong>HID (Human Interface Devices):</strong> Teclados, ratones, gamepads</li>
                    <li><strong>Touchscreens:</strong> Pantallas t√°ctiles capacitivas y resistivas</li>
                    <li><strong>Sensors:</strong> Aceler√≥metros, giroscopios, magnet√≥metros</li>
                    <li><strong>Haptic Feedback:</strong> Vibraci√≥n y feedback t√°ctil</li>
                </ul>
                <h3>Caracter√≠sticas:</h3>
                <ul class="feature-list">
                    <li>Multi-touch support</li>
                    <li>Gesture recognition</li>
                    <li>Accessibility features</li>
                    <li>Hot-plugging autom√°tico</li>
                    <li>Power management para dispositivos</li>
                </ul>
                <p><strong>Archivos:</strong> drivers/input/, drivers/hid/, drivers/iio/</p>
            </div>

        </section>

        <section id="descarga" class="section">
            <h1 class="titulo-guia">Descargas</h1>

            <div class="info-card">
                <p>
                    <li>La descarga del binario del kernel se expondr√° en esta secci√≥n cuando salga la primer versi√≥n
                        estable de la rama <strong>mainline</strong>.</li>
                </p>
                
            </div>
        </section>
    </div>

</body>

</html>