<!DOCTYPE html>
<html lang="en">
<!-- If you're reading this, first I already told you that I'm not using any trendy hipster framework like React, next, nest, whatever. At most Blazor. -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/Assets/cuatro-nucleos.png" type="image/x-icon">
    <title>IR0 Kernel - Wiki</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@300;400;500;700&family=Ubuntu+Mono&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <script src="main.js"></script>
    <script src="loc.js"></script>

    <nav class="navbar">
        <div class="nav-container">
            <div class="logo"><a href="index_en.html" target="_blank" rel="noopener noreferrer"
                    style="text-decoration: none; color: white;">IR0 Wiki</a></div>
            <ul class="nav-menu">
                <li><a href="#overview" class="nav-link active" onclick="showSection('overview')">Home</a></li>
                <li><a href="#architecture" class="nav-link" onclick="showSection('architecture')">Architecture</a></li>
                <li><a href="#branches" class="nav-link" onclick="showSection('branches')">Branches</a></li>
                <li><a href="#development" class="nav-link" onclick="showSection('development')">Development</a></li>
                <li><a href="#subsystems" class="nav-link" onclick="showSection('subsystems')">Subsystems</a></li>
                <li><a href="#overview" class="nav-link" onclick="showSection('descarga')">Download</a></li>
                <li class="language-dropdown">
                    <button class="translate-btn" onclick="toggleLanguageMenu()">üåê EN</button>
                    <div class="language-menu" id="languageMenu">
                        <a href="index_es.html" class="language-option">üá™üá∏ Espa√±ol</a>
                        <a href="index.html" class="language-option active">üá∫üá∏ English</a>
                    </div>
                </li>
                <li><button id="darkModeBtn" class="dark-mode-btn" onclick="toggleDarkMode()">üåô</button></li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <section id="overview" class="section active">
            <h1 class="titulo-principal">IR0 Kernel - Overview</h1>

            <div class="info-card">
                <p>
                    The purpose of this "wiki", web documentation, guide, however you call it, is to use it as a
                    personal memory aid
                    for kernel development.
                    It doesn't have to be an ultra-aesthetic page, but I'm trying hard so it doesn't show that I made it
                    with vanilla html, css and js like some amateur project
                    that's out there. <br> <br>
                    A minimally functional operating system kernel (all the <a
                        href="https://en.wikipedia.org/wiki/User_space_and_kernel_space" target="_blank"
                        rel="noopener noreferrer">Kernel Space</a> plus a minimal user space)
                    can easily run in <strong>15,000</strong> lines of code, so as you'll see;
                    it's humanly impossible to memorize and understand the entire kernel flow by myself. Besides, there
                    are many complex subsystems working together at a low level to mediate between hardware and
                    software.
                </p>
            </div>

            <div class="info-card">
                <p id="loc">
                </p>
                <p><small>This calculation is automatic and is done through an API that counts the number of lines of
                        code in the kernel (.c, .h, .asm, .rs, and .cpp)</small></p>
                <p><small>This deserves a star on the repo</small></p>

            </div>

            <div class="info-card">
                <h2>What is IR0?</h2>
                <p>
                    <strong>IR0</strong> is a <strong>multipurpose operating system kernel</strong> developed
                    from scratch for the <strong>x86-64</strong> architecture, written in <strong>C</strong>,
                    <strong>C++</strong>,
                    <strong>Rust</strong>, and <strong>ASM</strong>. The kernel core is in C, device drivers in Rust
                    (for memory safety), and advanced components like schedulers in C++ (for templates and RAII).
                    <br>
                    I'm creating it to learn more about operating systems and be able to use it as raw material
                    for another project that replicates <a href="https://learn.microsoft.com/es-es/windows/wsl/about"
                        target="_blank" rel="noopener noreferrer">WSL2</a> but with my own kernel.
                    I don't rule out scaling it enough to make it usable in minimal servers or even IoT,
                    but I understand that's in the very long term.
                    <br>
                    <br>
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank" rel="noopener noreferrer">This
                        is its GitHub Repository.</a>
                    <br>
                    <a href="https://discord.gg/XZ84aPXtxh" target="_blank" rel="noopener noreferrer">Discord
                        community</a>
                </p>
            </div>

            <div class="info-card">
                <h2>Main Implemented Features</h2>
                <ul class="feature-list">
                    <li>‚úÖ Monolithic modular kernel for x86-64 architecture</li>
                    <li>‚úÖ Complete virtual memory management with paging (MMU)</li>
                    <li>‚úÖ Complete interrupt and exception system (64 IDT vectors)</li>
                    <li>‚úÖ CFS (Completely Fair Scheduler) with Red-Black Tree</li>
                    <li>‚úÖ Complete process system with fork(), exit(), waitpid()</li>
                    <li>‚úÖ 23 implemented syscalls (from basic to memory management)</li>
                    <li>‚úÖ Complete MINIX filesystem with VFS (Virtual File System)</li>
                    <li>‚úÖ Hardware drivers: PS/2 (keyboard/mouse), ATA/IDE, Sound Blaster 16, VGA</li>
                    <li>‚úÖ Interactive shell in Ring 3 with built-in commands</li>
                    <li>‚úÖ Freestanding LibC with printf(), malloc(), free()</li>
                    <li>‚úÖ Multi-target build system (Desktop/Server/IoT/Embedded)</li>
                    <li>üîÑ Basic TCP/IP network stack (in development - using IoT library)</li>
                    <li>üîÑ Container support (in development)</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>Project Status</h2>
                <p><strong>Version:</strong> v0.0.1 pre-release candidate 1<br>
                    <strong>Architecture:</strong> x86-64 (primary), x86-32 (experimental), ARM (in development)<br>
                    <strong>Bootloader:</strong> GRUB<br>
                    <strong>License:</strong> GNU GPL v3.0<br>
                    <strong>Type:</strong> Monolithic Modular Kernel<br>
                    <strong>ASM Syntax:</strong> Intel (NASM)
                </p>
            </div>
        </section>

        <section id="architecture" class="section">
            <h1 class="titulo-principal">System Architecture</h1>

            <div class="architecture-box">
                <h3>IR0 Kernel Architecture Diagram</h3>
                <div class="kernel-architecture">
                    <!-- User Space -->
                    <div class="layer user-space">
                        <div class="layer-title">User Space (Ring 3)</div>
                        <div class="components">
                            <div class="component">Interactive Shell</div>
                            <div class="component">LibC (IR0)</div>
                            <div class="component">User Programs</div>
                            <div class="component">ELF Loader</div>
                        </div>
                    </div>

                    <!-- Kernel Space -->
                    <div class="layer kernel-space">
                        <div class="layer-title">Kernel Space (Ring 0) - IR0</div>
                        <div class="kernel-components">
                            <!-- System Interface -->
                            <div class="kernel-section system-interface">
                                <div class="section-title">System Interface</div>
                                <div class="component">23 Syscalls (IR0)</div>
                                <div class="component">INT 0x80 Handler</div>
                                <div class="component">Init System (PID 1)</div>
                            </div>

                            <!-- Process & Memory -->
                            <div class="kernel-section core-subsystems">
                                <div class="section-title">Process & Memory</div>
                                <div class="component">CFS Scheduler</div>
                                <div class="component">Virtual Memory (MMU)</div>
                                <div class="component">Heap Allocator</div>
                                <div class="component">Process Manager</div>
                            </div>

                            <!-- File System -->
                            <div class="kernel-section compatibility-section">
                                <div class="section-title">File System</div>
                                <div class="component">VFS Layer</div>
                                <div class="component">MINIX Filesystem</div>
                                <div class="component">File Operations</div>
                            </div>

                            <!-- Hardware Drivers -->
                            <div class="kernel-section hardware-abstraction">
                                <div class="section-title">Hardware Drivers</div>
                                <div class="component">PS/2 (Keyboard/Mouse)</div>
                                <div class="component">ATA/IDE Storage</div>
                                <div class="component">Sound Blaster 16</div>
                                <div class="component">VGA/VBE Video</div>
                            </div>

                            <!-- Interrupts & Timers -->
                            <div class="kernel-section system-interface">
                                <div class="section-title">Interrupts & Timers</div>
                                <div class="component">IDT (64 vectors)</div>
                                <div class="component">PIC Remapping</div>
                                <div class="component">Timer Cascade</div>
                                <div class="component">DMA Controller</div>
                            </div>

                            <!-- Network (Planned) -->
                            <div class="kernel-section core-subsystems">
                                <div class="section-title">Network (In Development)</div>
                                <div class="component">Basic TCP/IP (IoT)</div>
                                <div class="component">Socket Interface</div>
                                <div class="component">Ethernet Drivers</div>
                            </div>
                        </div>
                    </div>

                    <!-- Hardware -->
                    <div class="layer hardware">
                        <div class="layer-title">Hardware</div>
                        <div class="components">
                            <div class="component">CPU x86-64</div>
                            <div class="component">RAM (MMU)</div>
                            <div class="component">ATA/IDE Disks</div>
                            <div class="component">PS/2 Devices</div>
                            <div class="component">Sound Blaster</div>
                            <div class="component">VGA/VBE</div>
                        </div>
                    </div>
                </div>

                <!-- Legend -->
                <div class="architecture-legend">
                    <div class="legend-item">
                        <div class="legend-color user-space-color"></div>
                        <span>User Space (Ring 3) - Shell, LibC and user programs</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color kernel-space-color"></div>
                        <span>Kernel Space (Ring 0) - IR0 monolithic modular kernel</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color hardware-color"></div>
                        <span>Hardware - Supported physical components</span>
                    </div>
                </div>
            </div>
            <div class="info-card">
                <h2>Architecture and "Philosophy" of the project</h2>
                <p>
                    Unlike kernels such as <a href="https://en.wikipedia.org/wiki/Windows_NT" target="_blank"
                        rel="noopener noreferrer">Microsoft's NT kernel (Hybrid)</a>, <a
                        href="https://www.redox-os.org/" target="_blank" rel="noopener noreferrer">Redox-OS
                        (Microkernel)</a>,
                    or the same <a href="https://es.wikipedia.org/wiki/MINIX" target="_blank"
                        rel="noopener noreferrer">MINIX kernel (microkernel)</a>, IR0 is based on a more similar
                    architecture
                    to what Linux has, which is monolithic.
                    <br>

                    However, my main argument is that of performance. I understand that someone could come and
                    point out that, like any monolith, if a subcomponent breaks, the entire system crashes <small>(and
                        they would be right)</small>
                    but what I respond to that is <i>"What good does it do me that the kernel supports continuing
                        without
                        filesystem if I can't do anything practical without it?"</i>, that is, it doesn't make sense
                    that the
                    kernel
                    continues functioning <strong>without one of its key components running</strong>. <br><br>

                    That's why I don't see a better alternative (for now) than the <a
                        href="https://es.wikipedia.org/wiki/N%C3%BAcleo_monol%C3%ADtico" target="_blank"
                        rel="noopener noreferrer">monolithic</a> pattern. And it also saves me from having to
                    interconnect
                    key subsystems with each other via IPC, which impacts performance of the Operating System. It's not
                    perfect, but it's stable. It's not entirely traceable and requires scaling little by little, but if
                    it scales well it performs a lot. <br>

                    <br>
                    However, I also have disagreements with the <a
                        href="https://es.wikipedia.org/wiki/Filosof%C3%ADa_de_Unix" target="_blank"
                        rel="noopener noreferrer">UNIX philosophy</a>. They (among other things and very briefly)
                    consider
                    that if something fails, <i>let it fail well</i>. Which in kernel terms would be: <i>If the
                        scheduler breaks, Panic() directly. If you have memory corruption (in kernel space),
                        Panic.</i><br>
                    And it's not that I question it for no reason, I simply ask (although without solutions yet) <i>"Why
                        not rescue the system during Panic()?, or at least try"</i>. <br>
                    Beyond the philosophical point and to summarize, the kernel is monolithic because it's more
                    performant and
                    I feel that the key pieces of the kernel must <strong>work without overhead</strong>. <br>
                    However, if in the future I needed to integrate some specific subsystem in a hybrid way,
                    I would surely be pragmatic.
                </p>
                <h2>Kernel Space is sacred</h2>
                <p>
                    I know I talk as if IR0 were used by thousands of people and all the history, but I'm going to give
                    myself the luxury of opining
                    about it.
                    <br>So, the point is that kernel space <strong>has to be only habitable by subsystems
                        that work in that Environment</strong>,
                    nothing else. <br>
                    I understand that there are certain <a
                        href="https://www.reddit.com/r/riotgames/comments/1gxhfmh/the_future_of_riot_vanguard_and_kernel_level/"
                        target="_blank" rel="noopener noreferrer">manufacturers concerned about their clients'
                        security</a> who,
                    coincidentally, have access to <i>every interruption that the user makes (they know what keys you
                        press,
                        your session time every time you turn on the computer, etc.)</i> And all that because they have
                    software running in the <a href="https://en.wikipedia.org/wiki/User_space_and_kernel_space"
                        target="_blank" rel="noopener noreferrer">kernel space</a> with all the privileges that implies.
                    <br> <a href="https://en.wikipedia.org/wiki/Protection_ring" target="_blank"
                        rel="noopener noreferrer">RING 0</a> is only for the kernel. Everything that comes from RING 3
                    communicates with <i>syscalls()</i>, end of statement.
                </p>
                <h2>Network Approach: Basic but Functional</h2>
                <p>
                    For IR0 to work as support for basic servers and IoT applications, I need
                    <strong>fundamental network support</strong> but without the massive complexity of Linux's complete
                    stack.
                    <br><br>
                    In the Linux Kernel there are more or less <i>1,500,000</i> lines of code <strong>ONLY THE COMPLETE
                        NETWORK STACK</strong>. Instead of trying to port all of that, I've decided to use a more
                    pragmatic approach:
                    <br><br>
                    <strong>Basic implementation with IoT library:</strong>
                <ul class="feature-list">
                    <li>Lightweight and functional TCP/IP stack</li>
                    <li>Support for basic network connectivity</li>
                    <li>Simplified socket interface</li>
                    <li>Essential Ethernet drivers</li>
                    <li>Minimalist approach that keeps the kernel manageable</li>
                </ul>
                This allows me to have network functionality without adding millions of lines of code to the kernel.

                <h2>Advantages of the Basic Approach</h2>
                This approach with IoT library has several advantages:
                <ul class="feature-list">
                    <li>Keeps the kernel lightweight and manageable</li>
                    <li>Significantly reduces code complexity</li>
                    <li>Allows network functionality without millions of additional lines</li>
                    <li>Easier to debug and maintain</li>
                    <li>Sufficient for basic use cases and IoT</li>
                </ul>
                </p>

            </div>

            <div class="info-card">
                <h2>Directory Structure</h2>
                <p>
                    How the file structure can change constantly, I prefer you consult it in the
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank"
                        rel="noopener noreferrer">GitHub Repository</a>.
                </p>

            </div>

        </section>

        <section id="branches" class="section">
            <h1 class="titulo-principal">Branch Management</h1>
            <div class="info-card">
                <h2>Git Workflow</h2>
                <div class="code-block">
                    <article>Since it's the first time I write a project of this caliber, what I'm looking for
                        is that the Workflow for kernel development be
                        as clean, predictable and scalable as possible.
                        <br>
                        <br>
                        For that I use 3 main git branches in the
                        process: mainline, dev and feature (which although feature is not in the repository, it's the
                        one used as convention for
                        integrating new code).
                        Where only <strong>mainline</strong> and <strong>dev</strong> are the only 2 <i>upstream
                            branches</i>.
                        <br>
                        <br>
                        <strong>experimental</strong> is a branch
                        divergent to <strong>dev</strong>, and <strong>feature</strong> is the branch that is created to
                        send
                        contributions.
                    </article>
                </div>
            </div>

            <!-- mainline BRANCH -->
            <div class="branch-grid">
                <div class="branch-card">
                    <div class="branch-title">mainline</div>
                    <div class="status-badge status-stable">STABLE</div>
                    <p><strong>-</strong> Main branch with stable and tested code.</p>

                    <h3>Characteristics</h3>
                    <ul class="feature-list">
                        <li>Only tested and functional code</li>
                        <li>Complete documentation</li>
                        <li>My base for rc's.</li>
                        <li><strong>mainline is sacred</strong>, since this branch <strong>has to compile and boot
                                always</strong>. It's the most stable of the two upstream branches.
                        </li>
                    </ul>

                </div>
                <!-- DEV BRANCH -->
                <div class="branch-card">
                    <div class="branch-title">dev</div>
                    <div class="status-badge status-development">STAGING</div>
                    <p><strong>-</strong> Active development branch where new features are implemented and tested.
                    </p>

                    <h3>Characteristics:</h3>
                    <ul class="feature-list">
                        <li>It's the mirror of <strong>mainline</strong>.</li>
                        <li>What gets merged here doesn't have to go to <strong>mainline</strong>.</li>
                        <li>New features in development that convinced me of feature</li>
                        <li>Code patches, refactors and optimizations</li>
                        <li>It can contain temporary bugs that are resolved one way or another in this branch.</li>
                    </ul>

                </div>

                <!-- feat BRANCH -->
                <div class="branch-card">
                    <div class="branch-title">feature</div>
                    <div class="status-badge status-feat">DEVELOPMENT</div>
                    <p><strong>-</strong>
                        I add it because it's the branch where feats are created that later go to upstream
                        merging to <strong>dev</strong>. It's the most unstable of all because it's where new code is
                        integrated that must also be tested and reviewed before reaching merge.
                    </p>

                    <h3>Characteristics:</h3>
                    <ul class="feature-list">
                        <li>This is where I start to implement new functionalities or patches</li>
                        <li>It's the first one that gets debugged.</li>
                        <li>It's the one you would create when you fork the repo.</li>
                        <li>It's expected to compile before going to <strong>dev</strong>.</li>
                    </ul>
                </div>
                <!-- exp BRANCH -->

                <div class="branch-card">
                    <div class="branch-title">experimental</div>
                    <div class="status-badge status-exp">MISC</div>
                    <p><strong>-</strong>
                        In this branch, features are integrated unstable enough to end up in
                        <strong>mainline</strong>
                        but that may have potential in the future.
                    </p>

                    <h3>Characteristics:</h3>
                    <ul class="feature-list">
                        <li>It's a pure testing branch, it has nothing to do with stable upstream branches</li>
                        <li>Here fall the features and experiments that don't reach <strong>mainline</strong></li>
                        <li>Things that aren't tested in operating systems or new ideas</li>
                        <li>Stability is not so important in this branch</li>
                        <li>If they are tested enough without breaking anything, they may or may not merge to mainline
                            first
                            passing through <strong>dev</strong> again.
                        </li>
                    </ul>
                </div>

            </div>

            <div class="info-card">
                <h2>How is merging from feature to mainline?</h2>

                <article>
                    Basically, you create your improvement/optimization <strong>from a fork of the repo with a new
                        branch</strong> that will be something like <i>"feature/fix-scheduler"</i> for example. <br>
                    Then, <strong>you make PR to the upstream dev branch (not to mainline)</strong> and the review and
                    merge is done if applicable. <br>
                    The merge to mainline depends on <strong>how aligned with the project I consider the feature
                        is</strong>. <br>
                    Not even some of my own implementations would I merge directly to mainline for this same reason.
                </article>

            </div>

        </section>

        <section id="subsystems" class="section">
            <h1 class="titulo-principal">IR0 Kernel Subsystems</h1>

            <div class="info-card">
                <h2>Project Status</h2>
                <p><strong>Version:</strong> v0.0.01 pre-release candidate 1<br>
                    <strong>Architecture:</strong> x86-64 (primary), x86-32 (experimental), ARM (in development)<br>
                    <strong>License:</strong> GNU GPL v3.0<br>
                    <strong>Type:</strong> Monolithic Modular Kernel
                </p>
            </div>

            <div class="info-card">
                <h2>üèóÔ∏è Core Architecture</h2>
                <h3>‚úÖ Kernel Architecture</h3>
                <ul class="feature-list">
                    <li>Monolithic modular design with HAL abstraction</li>
                    <li>Multi-target build system (Desktop/Server/IoT/Embedded)</li>
                    <li>Ring 0 (kernel) / Ring 3 (user) separation</li>
                    <li>x86-64 primary support with multi-arch framework</li>
                    <li>Freestanding C environment with custom libc</li>
                </ul>

                <h3>‚úÖ Boot System</h3>
                <ul class="feature-list">
                    <li>GRUB multiboot specification compliance</li>
                    <li>x86-64 long mode initialization</li>
                    <li>GDT (Global Descriptor Table) setup</li>
                    <li>TSS (Task State Segment) configuration</li>
                    <li>IDT (Interrupt Descriptor Table) with 64 entries</li>
                </ul>

                <h3>‚úÖ Memory Management</h3>
                <ul class="feature-list">
                    <li>Virtual memory with paging (MMU)</li>
                    <li>Kernel heap allocator (simple + advanced WIP)</li>
                    <li>Memory protection (Ring 0/3 isolation)</li>
                    <li>Memory layout: Kernel (1MB-8MB), Heap (8MB-32MB), User (1GB+)</li>
                    <li>Page fault handling with CR2 fault address reading</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>‚öôÔ∏è Process Management</h2>
                <h3>‚úÖ Process System</h3>
                <ul class="feature-list">
                    <li>Complete process lifecycle management</li>
                    <li>Process states: READY, RUNNING, BLOCKED, ZOMBIE</li>
                    <li>PID assignment starting from PID 1</li>
                    <li>Process creation with fork() syscall</li>
                    <li>Process termination with exit() syscall</li>
                    <li>Parent-child relationships with waitpid()</li>
                </ul>

                <h3>‚úÖ Scheduler</h3>
                <ul class="feature-list">
                    <li>CFS (Completely Fair Scheduler) implementation</li>
                    <li>Red-Black Tree runqueue for O(log n) operations</li>
                    <li>Virtual runtime (vruntime) tracking for fairness</li>
                    <li>Nice values support (-20 to +19)</li>
                    <li>Preemptive multitasking with timer integration</li>
                    <li>Context switching in optimized x86-64 assembly</li>
                </ul>

                <h3>‚úÖ Init System</h3>
                <ul class="feature-list">
                    <li>PID 1 init process (mini-systemd)</li>
                    <li>Service management and respawning</li>
                    <li>User mode switching from kernel</li>
                    <li>Shell service management</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üîß System Calls</h2>
                <h3>‚úÖ Syscall Interface (23 syscalls implemented)</h3>
                <div class="code-block">
                    <pre>SYS_EXIT(0)         - Process termination
SYS_WRITE(1)        - Write to file descriptor
SYS_READ(2)         - Read from file descriptor
SYS_GETPID(3)       - Get process ID
SYS_GETPPID(4)      - Get parent process ID
SYS_LS(5)           - List directory contents
SYS_MKDIR(6)        - Create directory
SYS_PS(7)           - Show process list
SYS_WRITE_FILE(8)   - Write file to filesystem
SYS_CAT(9)          - Display file contents
SYS_TOUCH(10)       - Create empty file
SYS_RM(11)          - Remove file
SYS_FORK(12)        - Create child process
SYS_WAITPID(13)     - Wait for child process
SYS_RMDIR(40)       - Remove directory
SYS_MALLOC_TEST(50) - Memory allocation test
SYS_BRK(51)         - Change heap break
SYS_SBRK(52)        - Increment heap break
SYS_MMAP(53)        - Memory mapping
SYS_MUNMAP(54)      - Unmap memory
SYS_MPROTECT(55)    - Change memory protection
SYS_EXEC(56)        - Execute program</pre>
                </div>

                <h3>‚úÖ Syscall Mechanism</h3>
                <ul class="feature-list">
                    <li>INT 0x80 software interrupt interface</li>
                    <li>Register-based parameter passing</li>
                    <li>Kernel/user mode transition</li>
                    <li>Error handling and return values</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>‚ö° Interrupt System</h2>
                <h3>‚úÖ Interrupt Handling</h3>
                <ul class="feature-list">
                    <li>Complete IDT setup with 64 interrupt vectors</li>
                    <li>PIC (Programmable Interrupt Controller) remapping</li>
                    <li>ISR (Interrupt Service Routines) in assembly</li>
                    <li>IRQ handling for hardware devices</li>
                    <li>Timer interrupt integration</li>
                    <li>Keyboard interrupt (IRQ 1)</li>
                    <li>Mouse interrupt (IRQ 12)</li>
                    <li>Audio interrupt (IRQ 5)</li>
                </ul>

                <h3>‚úÖ Exception Handling</h3>
                <ul class="feature-list">
                    <li>Page fault handler with CR2 address reading</li>
                    <li>General protection fault handling</li>
                    <li>Division by zero exception</li>
                    <li>Invalid opcode exception</li>
                    <li>Stack fault handling</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üñ•Ô∏è Hardware Drivers</h2>
                <h3>‚úÖ Input Devices</h3>
                <ul class="feature-list">
                    <li>PS/2 Keyboard driver with circular buffer</li>
                    <li>PS/2 Mouse driver with 3/5 button + scroll wheel support</li>
                    <li>Mouse type detection (standard/wheel/5-button)</li>
                    <li>Configurable sample rates and resolution</li>
                </ul>

                <h3>‚úÖ Storage Devices</h3>
                <ul class="feature-list">
                    <li>ATA/IDE hard disk driver</li>
                    <li>CD-ROM support</li>
                    <li>Basic disk I/O operations</li>
                    <li>Sector-based read/write</li>
                </ul>

                <h3>‚úÖ Audio System</h3>
                <ul class="feature-list">
                    <li>Sound Blaster 16 driver</li>
                    <li>8-bit/16-bit audio support</li>
                    <li>Mono/Stereo playback</li>
                    <li>DMA-based audio transfer (channels 1 and 5)</li>
                    <li>Volume control (master and PCM)</li>
                    <li>Sample rate configuration</li>
                    <li>Audio format detection</li>
                </ul>

                <h3>‚úÖ Video System</h3>
                <ul class="feature-list">
                    <li>VGA text mode (80x25)</li>
                    <li>VBE (VESA BIOS Extensions) graphics support</li>
                    <li>Framebuffer access</li>
                    <li>Basic graphics primitives</li>
                </ul>

                <h3>‚úÖ Serial Communication</h3>
                <ul class="feature-list">
                    <li>COM1/COM2 serial port drivers</li>
                    <li>Debug output via serial</li>
                    <li>Configurable baud rates</li>
                    <li>Serial interrupt handling</li>
                </ul>

                <h3>‚úÖ Timer Systems</h3>
                <ul class="feature-list">
                    <li>PIT (Programmable Interval Timer)</li>
                    <li>RTC (Real Time Clock)</li>
                    <li>HPET (High Precision Event Timer)</li>
                    <li>LAPIC (Local APIC Timer)</li>
                    <li>Unified clock system abstraction</li>
                    <li>Timer cascade with best available timer selection</li>
                </ul>

                <h3>‚úÖ DMA Controller</h3>
                <ul class="feature-list">
                    <li>8-channel DMA support (0-7)</li>
                    <li>8-bit and 16-bit transfer modes</li>
                    <li>Audio DMA integration</li>
                    <li>Channel enable/disable control</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üìÅ File System</h2>
                <h3>‚úÖ Virtual File System (VFS)</h3>
                <ul class="feature-list">
                    <li>Unified filesystem abstraction layer</li>
                    <li>Multiple filesystem support framework</li>
                    <li>Standard file operations (open, read, write, close)</li>
                    <li>Directory operations (mkdir, rmdir, ls)</li>
                    <li>File metadata handling</li>
                </ul>

                <h3>‚úÖ MINIX Filesystem</h3>
                <ul class="feature-list">
                    <li>Complete MINIX filesystem implementation</li>
                    <li>Inode-based file storage</li>
                    <li>Directory structure support</li>
                    <li>File creation, deletion, and modification</li>
                    <li>Integrated with VFS layer</li>
                </ul>

                <h3>‚úÖ File Operations</h3>
                <ul class="feature-list">
                    <li>File creation (touch)</li>
                    <li>File deletion (rm)</li>
                    <li>Directory creation (mkdir)</li>
                    <li>Directory removal (rmdir)</li>
                    <li>File content display (cat)</li>
                    <li>Directory listing (ls)</li>
                    <li>File writing capabilities</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üë§ User Space</h2>
                <h3>‚úÖ C Library (LibC)</h3>
                <ul class="feature-list">
                    <li>Freestanding C library implementation</li>
                    <li>Standard headers: stdio.h, stdlib.h, unistd.h, stdint.h, stddef.h</li>
                    <li>I/O functions: printf(), puts(), putchar()</li>
                    <li>Memory functions: malloc(), free()</li>
                    <li>Process functions: exit(), getpid()</li>
                    <li>System call wrappers</li>
                </ul>

                <h3>‚úÖ Printf Implementation</h3>
                <ul class="feature-list">
                    <li>Format specifiers: %d (integers), %s (strings), %c (characters)</li>
                    <li>Variable argument support</li>
                    <li>Output to stdout</li>
                </ul>

                <h3>‚úÖ User Programs</h3>
                <ul class="feature-list">
                    <li>Echo command implementation</li>
                    <li>Shell integration for user programs</li>
                    <li>ELF loader (basic implementation)</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üêö Shell System</h2>
                <h3>‚úÖ Interactive Shell</h3>
                <ul class="feature-list">
                    <li>Command-line interface in Ring 3 (user mode)</li>
                    <li>Built-in commands: ls, ps, cat, mkdir, rmdir, touch, rm, fork, clear, help, exit, malloc, sbrk,
                        exec</li>
                </ul>

                <h3>‚úÖ Shell Features</h3>
                <ul class="feature-list">
                    <li>Command parsing and execution</li>
                    <li>Process management integration</li>
                    <li>Filesystem operation support</li>
                    <li>Memory management testing</li>
                    <li>Error handling and feedback</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üåê Network System</h2>
                <h3>üîÑ Basic TCP/IP Stack (In Development)</h3>
                <ul class="feature-list">
                    <li>Basic implementation using lightweight IoT library</li>
                    <li>Fundamental TCP/IP support for connectivity</li>
                    <li>Simplified socket interface</li>
                    <li>Basic Ethernet driver framework</li>
                    <li>Ping utility planned</li>
                    <li>Minimalist approach to reduce complexity</li>
                </ul>
                <p><small><strong>Note:</strong> Opted for a basic implementation with IoT library instead of porting
                        Linux's complete stack (1.5M lines) to keep the kernel lightweight and manageable.</small></p>
            </div>

            <div class="info-card">
                <h2>üîß Build System</h2>
                <h3>‚úÖ Multi-Target Build</h3>
                <ul class="feature-list">
                    <li>Desktop target (full features, 256MB heap, 1024 processes)</li>
                    <li>Server target (optimized networking, 1GB heap, 4096 processes)</li>
                    <li>IoT target (power management, 16MB heap, 64 processes)</li>
                    <li>Embedded target (minimal features, 4MB heap, 16 processes)</li>
                </ul>

                <h3>‚úÖ Multi-Architecture</h3>
                <ul class="feature-list">
                    <li>x86-64 production support</li>
                    <li>x86-32 experimental support</li>
                    <li>ARM development framework</li>
                    <li>Architecture abstraction layer (HAL)</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>‚ö†Ô∏è Current Limitations</h2>
                <h3>‚ùå Not Yet Implemented</h3>
                <ul class="feature-list">
                    <li>SMP (Symmetric Multiprocessing) support</li>
                    <li>Dynamic kernel modules</li>
                    <li>Advanced IPC (pipes, message queues)</li>
                    <li>Network stack (TCP/IP)</li>
                    <li>USB support</li>
                    <li>Advanced GUI/Window manager</li>
                    <li>Signal handling</li>
                    <li>Copy-on-write memory</li>
                    <li>Swap memory support</li>
                    <li>Advanced filesystem features (ext2/3/4)</li>
                </ul>

                <h3>‚ö†Ô∏è Known Issues</h3>
                <ul class="feature-list">
                    <li>Fork() context switching needs refinement</li>
                    <li>Limited ELF loader functionality</li>
                    <li>No zombie process reaping in init</li>
                    <li>Basic memory allocator (advanced versions in development)</li>
                    <li>Single CPU support only</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üìä Technical Specifications</h2>
                <h3>Memory Layout</h3>
                <div class="code-block">
                    <pre>Kernel Space: 0x100000 - 0x800000 (1MB-8MB)
Heap Space:   0x800000 - 0x2000000 (8MB-32MB, 24MB total)
User Space:   0x40000000+ (1GB+)</pre>
                </div>

                <h3>Performance Metrics</h3>
                <ul class="feature-list">
                    <li>Context switch time: ~microseconds (assembly optimized)</li>
                    <li>Scheduler complexity: O(log n) with Red-Black Tree</li>
                    <li>Memory allocation: O(1) for simple allocator</li>
                    <li>Interrupt latency: Minimal with optimized ISRs</li>
                </ul>

                <h3>Resource Limits (Desktop Target)</h3>
                <ul class="feature-list">
                    <li>Maximum processes: 1024</li>
                    <li>Maximum threads: 4096</li>
                    <li>Heap size: 256MB</li>
                    <li>Scheduler quantum: 10ms</li>
                    <li>I/O buffer size: 64KB</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üéØ Roadmap</h2>
                <h3>Short Term (Next Release)</h3>
                <ul class="feature-list">
                    <li>Fix fork() context switching issues</li>
                    <li>Implement proper zombie reaping</li>
                    <li>Integrate basic TCP/IP stack with IoT library</li>
                    <li>Improve ELF loader</li>
                    <li>Add USB framework</li>
                </ul>

                <h3>Medium Term</h3>
                <ul class="feature-list">
                    <li>SMP support</li>
                    <li>Advanced GUI system</li>
                    <li>Basic networking expansion (more protocols, optimizations)</li>
                    <li>Dynamic kernel modules</li>
                    <li>Advanced IPC mechanisms</li>
                </ul>

                <h3>Long Term</h3>
                <ul class="feature-list">
                    <li>Native application support (Doom, GCC, Bash)</li>
                    <li>Complete POSIX compatibility</li>
                    <li>Advanced filesystem support</li>
                    <li>Hardware abstraction improvements</li>
                    <li>Performance optimizations</li>
                </ul>
            </div>
        </section>

        <section id="development" class="section">
            <h1 class="titulo-guia">Development Guide</h1>

            <div class="info-card">
                <p>
                <div class="code-block">
                    <strong>-</strong> This section is in case someone is interested in contributing to the project.
                    <strong>They are not
                        strict rules, they are simply recommendations
                        to make it more bearable.</strong>
                </div>
                </p>
                <h2>What do you need to know to contribute?</h2>
                More than anything the following:
                <li>Know structured/functional/object-oriented programming as necessary for the language.
                </li>
                <li>Know C or C++ or Rust.</li>
                <li>Assembly if you contribute to subsystems very close to the hardware, but I recommend knowing the
                    basics to know how <i>panic(), boot.asm, etc.</i> work</li>
                <li><strong>Know how a makefile works</strong>, how to compile subsystems by parts, why
                    subsystems have to be compiled separately with their own makefile</li>
                <li><strong>General development tools</strong>: GIT/GitHub, how to create, change, pull and launch PR's
                    between branches</li>
                <li><strong>Basic QEMU.</strong> How the VM works, how the generated image is loaded when compiling the
                    kernel.</li>
                <li><strong>Knowing Bash is a plus for quick testing</strong>, since you can start QEMU with a script
                    without repeating the complete command.</li>
                <li>Communication. <strong>Argue decisions about PR's</strong>, debate healthily about it.
                </li>
                <li>Know how to use AI's in general to optimize debugging and adapt it to code conventions.
                </li>
                <li>Know that, when contributing, <strong>you can be maintainer of the subsystem you contributed
                        to</strong>. And if
                    you can't provide maintenance recurrent to the subsystem, <strong>leave it well documented</strong>.
                </li>
                <br>
                Similarly, <strong>you don't have to be an expert to contribute to the kernel. Simply with having the
                    desire
                    to learn/study about what you're going to contribute is more than enough</strong>.

                <h2>Environment Setup</h2>
                <h3>Required Dependencies:</h3>
                <li>Basically have installed: the C/Cpp compiler (gcc/g++), the asm compiler (nasm), make
                    for compilation and
                    QEMU as test vm.
                </li>
                I would give you the commands or websites to install, but chatgpt can solve it better for you.
                <br><br>

                <div class="code-block">
                    <strong>NOTE</strong>: Since this project is a kernel, it's <i>Freestanding</i>. That means you
                    <strong>can't include libraries like
                        stdio.h to do a <code>print(), write()</code>, etc. because there's no operating system that
                        responds to those functions </strong>. <strong>You are the
                        operating system</strong>. that's why, in the repo I have the folder of dependencies "includes".
                    </strong>
                </div>

            </div>
            <div class="info-card">
                <h2>How do I write code?</h2>
                <h3>Naming Conventions:</h3>
                <ul class="feature-list">
                    <li>Functions: <code>snake_case()</code></li>
                    <li>Macros: <code>UPPER_CASE</code></li>
                    <li>Structs: <code>struct_name_t</code></li>
                    <li>Global variables: <code>g_variable_name</code></li>
                    <li>Constants: <code>CONSTANT_NAME</code></li>
                    <li>includes: <code>#INCLUDE -ir0/Lib.h - </code>(are being migrated to that format)</li>
                </ul>
                <h3>Comments:</h3>
                <ul class="feature-list">
                    <li>header files .h of documented functions</li>
                    <li>Source code files with comments in some functions, but more limited</li>
                    <li>Explanation of complex algorithms</li>
                    <li>TO DO's clearly marked</li>
                    <li>References to technical documentation</li>
                </ul>
                <small>This is approximate. I generally try to respect those conventions as much as I can.</small>
                <br><br>
                <li>Something like this would be in this example an average source code file:</li>
                <br>
                <img src="/Assets/funcion.c.png" alt="" srcset="" style="width: 50%;">
                <br>
                <i>Notice how I use the braces below the function name and the same in conditionals,
                    loops, etc. Also how I don't use them directly when the conditional has a single line
                    or there's certain nesting.</i>
                <br>
                <br>
                <li>This is how I handle headers (or most):</li>
                <br><br>
                <img src="/Assets/header.png" alt="" srcset="">
                <br>
                <i>Large comments usually go in these .h and in the source we make notes.</i>
            </div>

            <div class="info-card">
                <h2>üîß Setup and Compilation</h2>

                <h3>Dependency Verification</h3>
                <p><strong>IMPORTANT:</strong> Before compiling, it's recommended to verify that all dependencies are
                    correctly installed:</p>
                <div class="code-block">
                    <pre>make deptest</pre>
                </div>
                <p>This command will verify the presence of <strong>all</strong> necessary tools:</p>
                <ul class="feature-list">
                    <li><strong>Essential Tools:</strong> GCC, NASM, LD, Make, QEMU, GRUB</li>
                    <li><strong>Multi-Language Compilers (REQUIRED):</strong> G++/Clang++, Rustc, Cargo, rust-src</li>
                    <li><strong>Cross-Compilation:</strong> MinGW-w64 (for compiling to Windows from Linux)</li>
                    <li><strong>Python:</strong> Python 3, tkinter, PIL/Pillow</li>
                </ul>
                <p>The script automatically detects your platform and provides specific installation instructions if any
                    tool is missing.</p>


                <h3>Required Tools</h3>
                <h4>Essential:</h4>
                <ul class="feature-list">
                    <li><strong>GCC</strong> - C Compiler</li>
                    <li><strong>NASM</strong> - Assembler</li>
                    <li><strong>LD</strong> - ELF x86-64 Linker</li>
                    <li><strong>Make</strong> - Build automation</li>
                </ul>

                <h4>Runtime:</h4>
                <ul class="feature-list">
                    <li><strong>QEMU</strong> (qemu-system-x86_64) - Emulator</li>
                    <li><strong>GRUB</strong> (grub-mkrescue) - Bootable ISO creation</li>
                </ul>

                <h4>Optional:</h4>
                <ul class="feature-list">
                    <li><strong>Python 3</strong> - Kernel configuration system</li>
                </ul>

                <h4>Multi-Language Support (REQUIRED since v0.0.1-pre.1):</h4>
                <ul class="feature-list">
                    <li><strong>G++ / Clang++</strong> - C++ compiler (for advanced kernel components)</li>
                    <li><strong>Rustc + Cargo</strong> - Rust compiler (for device drivers)</li>
                    <li><strong>rust-src</strong> - Rust component for no_std development</li>
                </ul>

                <h3>Multi-Language Support</h3>
                <p>IR0 now supports development in <strong>three languages</strong>:</p>
                <ul class="feature-list">
                    <li><strong>C</strong> - Kernel core, memory management, system calls</li>
                    <li><strong>Rust</strong> - Device drivers (network, storage, USB) with memory safety</li>
                    <li><strong>C++</strong> - Advanced components (schedulers, protocol stacks) with templates and RAII
                    </li>
                </ul>

                <h4>Installing Rust:</h4>
                <div class="code-block">
                    <pre># Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Add required components
rustup component add rust-src
rustup target add x86_64-unknown-none

# Verify installation
rustc --version
cargo --version</pre>
                </div>

                <h4>Installing C++:</h4>
                <div class="code-block">
                    <pre># Debian/Ubuntu
sudo apt-get install g++

# Arch Linux
sudo pacman -S gcc

# Verify installation
g++ --version</pre>
                </div>

                <h3>Installation on Linux</h3>
                <div class="code-block">
                    <pre># Debian/Ubuntu
sudo apt-get install build-essential nasm qemu-system-x86 grub-pc-bin python3

# Arch Linux
sudo pacman -S base-devel nasm qemu grub python</pre>
                </div>

                <h3>Compilation Commands</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background-color: var(--card-bg); border-bottom: 2px solid var(--accent-color);">
                            <th style="padding: 0.75rem; text-align: left;">Command</th>
                            <th style="padding: 0.75rem; text-align: left;">Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 0.75rem;"><code>make ir0</code></td>
                            <td style="padding: 0.75rem;">Complete build: kernel ISO + userspace programs</td>
                        </tr>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 0.75rem;"><code>make kernel-x64.bin</code></td>
                            <td style="padding: 0.75rem;">Build only the kernel binary</td>
                        </tr>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 0.75rem;"><code>make kernel-x64.iso</code></td>
                            <td style="padding: 0.75rem;">Create bootable ISO image</td>
                        </tr>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 0.75rem;"><code>make userspace-programs</code></td>
                            <td style="padding: 0.75rem;">Build only userspace programs</td>
                        </tr>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 0.75rem;"><code>make clean</code></td>
                            <td style="padding: 0.75rem;">Clean all build artifacts</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem;"><code>make userspace-clean</code></td>
                            <td style="padding: 0.75rem;">Clean only userspace programs</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Running in QEMU</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background-color: var(--card-bg); border-bottom: 2px solid var(--accent-color);">
                            <th style="padding: 0.75rem; text-align: left;">Command</th>
                            <th style="padding: 0.75rem; text-align: left;">Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 0.75rem;"><code>make run</code></td>
                            <td style="padding: 0.75rem;">Run with GUI + virtual disk (recommended)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 0.75rem;"><code>make run-debug</code></td>
                            <td style="padding: 0.75rem;">Run with GUI + serial debug output</td>
                        </tr>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 0.75rem;"><code>make debug</code></td>
                            <td style="padding: 0.75rem;">Run with detailed QEMU logging</td>
                        </tr>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 0.75rem;"><code>make run-nodisk</code></td>
                            <td style="padding: 0.75rem;">Run without virtual disk</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem;"><code>make run-console</code></td>
                            <td style="padding: 0.75rem;">Run in console mode (no GUI)</td>
                        </tr>
                    </tbody>
                </table>

                <p><strong>QEMU Configuration:</strong></p>
                <ul class="feature-list">
                    <li>Memory: 512MB</li>
                    <li>Display: GTK (configurable to SDL2)</li>
                    <li>Serial: stdio (for debug)</li>
                    <li>Flags: <code>-no-reboot -no-shutdown</code></li>
                    <li>Debug log: <code>qemu_debug.log</code></li>
                </ul>

                <h3>Virtual Disk Management</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background-color: var(--card-bg); border-bottom: 2px solid var(--accent-color);">
                            <th style="padding: 0.75rem; text-align: left;">Command</th>
                            <th style="padding: 0.75rem; text-align: left;">Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 0.75rem;"><code>make create-disk</code></td>
                            <td style="padding: 0.75rem;">Create virtual disk image (disk.img)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem;"><code>make delete-disk</code></td>
                            <td style="padding: 0.75rem;">Delete virtual disk image</td>
                        </tr>
                    </tbody>
                </table>

                <p><strong>Disk specifications:</strong></p>
                <ul class="feature-list">
                    <li>Size: 100MB (configurable)</li>
                    <li>Format: RAW</li>
                    <li>Filesystem: MINIX</li>
                    <li>Script: <code>scripts/create_disk.sh</code></li>
                </ul>

                <h3>Utility Commands</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                    <thead>
                        <tr style="background-color: var(--card-bg); border-bottom: 2px solid var(--accent-color);">
                            <th style="padding: 0.75rem; text-align: left;">Command</th>
                            <th style="padding: 0.75rem; text-align: left;">Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 0.75rem;"><code>make deptest</code></td>
                            <td style="padding: 0.75rem;">Verify all system dependencies</td>
                        </tr>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 0.75rem;"><code>make help</code></td>
                            <td style="padding: 0.75rem;">Show complete Makefile help</td>
                        </tr>
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 0.75rem;"><code>make menuconfig</code></td>
                            <td style="padding: 0.75rem;">Launch kernel configuration (ncurses)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem;"><code>make unibuild FILE=&lt;file&gt;</code></td>
                            <td style="padding: 0.75rem;">Compile individual file</td>
                        </tr>
                    </tbody>
                </table>

                <p><strong>unibuild System - Multi-Language Compilation:</strong></p>
                <p>The unibuild system now supports compiling files in C, C++, and Rust with specific flags:</p>
                <div class="code-block">
                    <pre># Compile C files (default)
make unibuild FILE=kernel/memory/kmalloc.c

# Compile C++ files
make unibuild -cpp FILE=kernel/scheduler/advanced_sched.cpp

# Compile Rust drivers
make unibuild -rust FILE=drivers/network/rtl8139.rs

# Cross-compile to Windows (from Linux)
make unibuild -win FILE=kernel/file.c
make unibuild -win -cpp FILE=kernel/component.cpp
make unibuild -win -rust FILE=drivers/driver.rs

# Compile multiple files
make unibuild FILES="fs/ramfs.c fs/vfs.c"</pre>
                </div>
                <p><strong>Available flags:</strong></p>
                <ul class="feature-list">
                    <li><code>-cpp</code> - Use C++ compiler (g++)</li>
                    <li><code>-rust</code> - Use Rust compiler (rustc)</li>
                    <li><code>-win</code> - Cross-compile to Windows using MinGW-w64</li>
                </ul>
                <p>Flags can be combined for different use cases (e.g., <code>-win -cpp</code> to cross-compile C++ to
                    Windows).</p>


                <h3>Recommended Workflow</h3>
                <ol class="feature-list">
                    <li><strong>Verify dependencies:</strong> <code>make deptest</code></li>
                    <li><strong>Build the kernel:</strong> <code>make ir0</code></li>
                    <li><strong>Create virtual disk:</strong> <code>make create-disk</code> (first time)</li>
                    <li><strong>Run in QEMU:</strong> <code>make run</code></li>
                    <li><strong>For debugging:</strong> <code>make run-debug</code></li>
                </ol>
            </div>
        </section>

        <section id="panic" class="section">
            <h1 class="titulo-guia">Kernel Subsystems</h1>
            <div class="code-block">
                <p>
                    <strong>-</strong> This section details the main subsystems that compose the IR0 kernel,
                    their current development status and technical characteristics of each one.
                    <br>
                    <br>
                    The best way to understand the internal operation is by reviewing the source code in the
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank" rel="noopener noreferrer"
                        class="link-repo">GitHub Repository</a>.
                </p>
            </div>

            <div class="info-card">
                <h2>üîÑ Scheduler</h2>
                <p>
                    The scheduler is the heart of the multiprocessing system. Currently implements a simple
                    <a href="https://en.wikipedia.org/wiki/Round-robin_scheduling" target="_blank"
                        rel="noopener noreferrer">Round-Robin</a> algorithm as fallback, but the goal is to migrate to a
                    preemptive scheduler with priority scheme similar to Linux's CFS (Completely Fair Scheduler).
                </p>
                <h3>Current Features:</h3>
                <ul class="feature-list">
                    <li>Round-Robin algorithm with fixed quantum</li>
                    <li>Support for multiple priority levels</li>
                    <li>Basic process state management (Ready, Running, Blocked)</li>
                    <li>Optimized context switching in assembly</li>
                </ul>
                <h3>Upcoming Improvements:</h3>
                <ul class="feature-list">
                    <li>Preemptive scheduler implementation</li>
                    <li>CFS algorithm for fair CPU distribution</li>
                    <li>Real-time scheduling support</li>
                    <li>Load balancing between cores</li>
                </ul>
                <p><strong>Files:</strong> scheduler/scheduler.c, scheduler/task.h, scheduler/switch/switch.asm</p>
            </div>

            <div class="info-card">
                <h2>üíæ Filesystem</h2>
                <p>
                    Own filesystem based on <a href="https://es.wikipedia.org/wiki/Ext2" target="_blank"
                        rel="noopener noreferrer">EXT2</a> but with modern innovations. The distinctive feature
                    is the integration of a vectorial database to optimize file search and indexing operations.
                </p>
                <h3>Technical Features:</h3>
                <ul class="feature-list">
                    <li>Hierarchical directory structure</li>
                    <li>Support for files up to 2TB</li>
                    <li>Journaling for failure recovery</li>
                    <li>Transparent file compression</li>
                    <li>Vectorial indexing for fast searches</li>
                </ul>
                <h3>Innovations:</h3>
                <ul class="feature-list">
                    <li>Integration with <a href="https://github.com/victor-base/libvictor" target="_blank"
                            rel="noopener noreferrer">libvictor</a> for semantic searches</li>
                    <li>Intelligent cache based on access patterns</li>
                    <li>Extended metadata support</li>
                    <li>File-level encryption</li>
                </ul>
                <p><strong>Status:</strong> Active development</p>
                <p><strong>Files:</strong> fs/ext2.c, fs/victor_index.c, fs/journal.c</p>
            </div>

            <div class="info-card">
                <h2>‚ö° Interrupt System</h2>
                <p>
                    Robust interrupt and exception handling system that ensures kernel stability
                    and provides a clean interface for handling hardware and software events.
                </p>
                <h3>Main Components:</h3>
                <ul class="feature-list">
                    <li><strong>IDT (Interrupt Descriptor Table):</strong> 256-entry table for interrupt mapping</li>
                    <li><strong>ISR (Interrupt Service Routines):</strong> Optimized handlers in assembly</li>
                    <li><strong>Exception Handler:</strong> Processor exception handling</li>
                    <li><strong>IRQ Manager:</strong> Hardware interrupt management</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Complete page fault handling with automatic recovery</li>
                    <li>Nested interrupts with priorities</li>
                    <li>Deferred interrupt processing</li>
                    <li>Interrupt coalescing for optimization</li>
                </ul>
                <p><strong>Files:</strong> interrupt/idt.c, interrupt/interrupt.asm, interrupt/isr_handlers.c,
                    interrupt/irq.c</p>
            </div>

            <div class="info-card">
                <h2>üöÄ Boot Subsystem</h2>
                <p>
                    Initialization system that prepares the environment for kernel execution, handling the
                    transition from bootloader to user space.
                </p>
                <h3>Boot Phases:</h3>
                <ul class="feature-list">
                    <li><strong>Phase 1:</strong> Processor initialization and protected mode</li>
                    <li><strong>Phase 2:</strong> Paging and virtual memory configuration</li>
                    <li><strong>Phase 3:</strong> Critical subsystems initialization</li>
                    <li><strong>Phase 4:</strong> First process loading (init)</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Support for multiple architectures (x86-64, ARM64)</li>
                    <li>Independent bootloader with UEFI support</li>
                    <li>Automatic recovery from boot failures</li>
                    <li>Integrated recovery mode</li>
                </ul>
                <img src="/Assets/diag.png" alt="Boot diagram" srcset="" style="width: 100%;">
                <p><strong>Files:</strong> boot/boot.asm, boot/kmain.c, boot/arch.c, boot/kernel_start.c</p>
            </div>

            <div class="info-card">
                <h2>üõ°Ô∏è Memory Management</h2>
                <p>
                    Advanced memory management system that provides process isolation, performance optimization
                    and protection against unauthorized access.
                </p>
                <h3>Components:</h3>
                <ul class="feature-list">
                    <li><strong>Memory Manager:</strong> Physical and virtual page management</li>
                    <li><strong>Page Allocator:</strong> Efficient memory allocation</li>
                    <li><strong>Slab Allocator:</strong> Optimization for small objects</li>
                    <li><strong>Memory Protection:</strong> Access control and permissions</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>4-level paging (48-bit addressing)</li>
                    <li>Transparent memory compression</li>
                    <li>NUMA awareness for multi-socket systems</li>
                    <li>Memory deduplication</li>
                </ul>
                <p><strong>Files:</strong> mm/page_alloc.c, mm/slab.c, mm/vmalloc.c, mm/protection.c</p>
            </div>

            <div class="info-card">
                <h2>üåê Network Subsystem</h2>
                <p>
                    Complete network stack based on Linux but optimized for the IR0 kernel, providing
                    support for modern protocols and specific optimizations.
                </p>
                <h3>Supported Protocols:</h3>
                <ul class="feature-list">
                    <li>Complete TCP/IP stack</li>
                    <li>UDP with latency optimizations</li>
                    <li>HTTP/2 and HTTP/3</li>
                    <li>QUIC for fast connections</li>
                    <li>IPv6 with automatic transition</li>
                </ul>
                <h3>Optimizations:</h3>
                <ul class="feature-list">
                    <li>Zero-copy networking</li>
                    <li>Kernel bypass for high-performance applications</li>
                    <li>Network function virtualization (NFV)</li>
                    <li>Intelligent load balancing</li>
                </ul>
                <p><strong>Status:</strong> Integration with Linux networking stack</p>
                <p><strong>Files:</strong> net/tcp.c, net/udp.c, net/socket.c, net/protocols/</p>
            </div>

            <div class="info-card">
                <h2>üîß Driver Subsystem</h2>
                <p>
                    Modular framework for hardware driver development and management, with support for
                    hot-plugging and automatic device management.
                </p>
                <h3>Driver Types:</h3>
                <ul class="feature-list">
                    <li><strong>Block Devices:</strong> Disks, SSDs, storage devices</li>
                    <li><strong>Character Devices:</strong> Terminals, input devices</li>
                    <li><strong>Network Devices:</strong> Network cards, WiFi, Bluetooth</li>
                    <li><strong>Graphics:</strong> GPUs, framebuffers, hardware acceleration</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Unified driver framework</li>
                    <li>Hardware auto-detection</li>
                    <li>Integrated power management</li>
                    <li>Driver signing and verification</li>
                </ul>
                <p><strong>Files:</strong> drivers/core.c, drivers/block/, drivers/char/, drivers/net/</p>
            </div>

            <div class="info-card">
                <h2>üîê Security System</h2>
                <p>
                    Comprehensive security framework that protects the kernel and user processes, implementing
                    multiple layers of protection and security auditing.
                </p>
                <h3>Security Components:</h3>
                <ul class="feature-list">
                    <li><strong>Access Control:</strong> Role-based access control (RBAC)</li>
                    <li><strong>Capability System:</strong> Granular capability system</li>
                    <li><strong>Seccomp:</strong> Syscall filtering for sandboxing</li>
                    <li><strong>LSM (Linux Security Modules):</strong> Interchangeable security modules</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>ASLR (Address Space Layout Randomization)</li>
                    <li>Stack canaries and buffer overflow protection</li>
                    <li>Automatic kernel hardening</li>
                    <li>Security event auditing</li>
                    <li>TPM integration for integrity measurement</li>
                </ul>
                <p><strong>Files:</strong> security/capability.c, security/seccomp.c, security/lsm/, security/audit.c
                </p>
            </div>

            <div class="info-card">
                <h2>‚ö° Power Management</h2>
                <p>
                    Advanced power management system that optimizes battery consumption in mobile devices
                    and reduces energy consumption in servers while maintaining performance.
                </p>
                <h3>Power States:</h3>
                <ul class="feature-list">
                    <li><strong>Suspend to RAM:</strong> Fast suspension with instant recovery</li>
                    <li><strong>Suspend to Disk:</strong> Complete hibernation</li>
                    <li><strong>Standby:</strong> Low-power standby mode</li>
                    <li><strong>Dynamic Frequency Scaling:</strong> Dynamic CPU frequency adjustment</li>
                </ul>
                <h3>Optimizations:</h3>
                <ul class="feature-list">
                    <li>Intelligent CPU idle management</li>
                    <li>Wake-on-LAN and wake-on-timer</li>
                    <li>Power capping for servers</li>
                    <li>Automatic thermal management</li>
                    <li>Battery health monitoring</li>
                </ul>
                <p><strong>Files:</strong> power/suspend.c, power/cpuidle.c, power/thermal.c, power/battery.c</p>
            </div>

            <div class="info-card">
                <h2>üéØ Virtualization</h2>
                <p>
                    Virtualization subsystem that allows running multiple operating systems simultaneously,
                    with support for containers and complete virtual machines.
                </p>
                <h3>Virtualization Types:</h3>
                <ul class="feature-list">
                    <li><strong>Containers:</strong> Light isolation with namespaces and cgroups</li>
                    <li><strong>KVM:</strong> Kernel-based Virtual Machine for complete VMs</li>
                    <li><strong>Xen:</strong> Type 1 hypervisor for bare-metal virtualization</li>
                    <li><strong>Docker/OCI:</strong> Support for container standards</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Hardware-assisted virtualization (Intel VT-x, AMD-V)</li>
                    <li>Nested virtualization</li>
                    <li>Live VM migration</li>
                    <li>GPU passthrough for graphics acceleration</li>
                    <li>Memory ballooning and overcommit</li>
                </ul>
                <p><strong>Files:</strong> virt/kvm/, virt/xen/, kernel/nsproxy.c, kernel/cgroup.c</p>
            </div>

            <div class="info-card">
                <h2>üìä Monitoring and Debugging</h2>
                <p>
                    Complete monitoring and debugging system that provides deep visibility into kernel operation
                    and enables real-time problem diagnosis.
                </p>
                <h3>Debugging Tools:</h3>
                <ul class="feature-list">
                    <li><strong>Kprobes:</strong> Dynamic insertion points in the kernel</li>
                    <li><strong>ftrace:</strong> Function and event tracer</li>
                    <li><strong>perf:</strong> Advanced performance profiler</li>
                    <li><strong>eBPF:</strong> Dynamic kernel programming</li>
                </ul>
                <h3>Metrics and Monitoring:</h3>
                <ul class="feature-list">
                    <li>CPU, memory and I/O profiling</li>
                    <li>Network packet tracing</li>
                    <li>System call monitoring</li>
                    <li>Kernel panic analysis</li>
                    <li>Performance counters</li>
                </ul>
                <p><strong>Files:</strong> kernel/trace/, kernel/debug/, kernel/profiling/, kernel/bpf/</p>
            </div>

            <div class="info-card">
                <h2>üîß Device Tree</h2>
                <p>
                    Hardware description system that allows the kernel to automatically discover and configure
                    hardware devices without needing hardcoded specific drivers.
                </p>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Declarative hardware description</li>
                    <li>Support for multiple architectures</li>
                    <li>Dynamic overlays for configuration</li>
                    <li>UEFI/ACPI firmware compatibility</li>
                </ul>
                <h3>Benefits:</h3>
                <ul class="feature-list">
                    <li>Faster boot on embedded systems</li>
                    <li>Automatic device configuration</li>
                    <li>Cross-platform portability</li>
                    <li>Reduction of platform-specific code</li>
                </ul>
                <p><strong>Files:</strong> drivers/of/, drivers/acpi/, drivers/firmware/</p>
            </div>

            <div class="info-card">
                <h2>üéÆ Graphics and Multimedia</h2>
                <p>
                    Graphics subsystem that provides hardware acceleration, multi-monitor support
                    and advanced multimedia capabilities.
                </p>
                <h3>Graphics Components:</h3>
                <ul class="feature-list">
                    <li><strong>DRM (Direct Rendering Manager):</strong> Modern graphics management</li>
                    <li><strong>KMS (Kernel Mode Setting):</strong> Display mode configuration</li>
                    <li><strong>GEM (Graphics Execution Manager):</strong> Graphics memory management</li>
                    <li><strong>V4L2:</strong> Video4Linux for video capture</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Support for modern GPUs (NVIDIA, AMD, Intel)</li>
                    <li>Hardware video acceleration</li>
                    <li>Multi-head display</li>
                    <li>HDR and color management</li>
                    <li>VR/AR support</li>
                </ul>
                <p><strong>Files:</strong> drivers/gpu/drm/, drivers/media/, drivers/video/</p>
            </div>

            <div class="info-card">
                <h2>üîä Audio Subsystem</h2>
                <p>
                    Advanced audio system that provides support for multiple formats, real-time audio processing
                    and management of complex audio devices.
                </p>
                <h3>Audio Components:</h3>
                <ul class="feature-list">
                    <li><strong>ALSA (Advanced Linux Sound Architecture):</strong> Main audio framework</li>
                    <li><strong>PulseAudio:</strong> Sound server for users</li>
                    <li><strong>JACK:</strong> Low-latency professional audio</li>
                    <li><strong>ASoC (ALSA System on Chip):</strong> Audio for embedded systems</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>HD format support (24-bit, 192kHz)</li>
                    <li>7.1 surround audio</li>
                    <li>Noise cancellation</li>
                    <li>Bluetooth audio (A2DP, aptX)</li>
                    <li>MIDI and audio synthesis</li>
                </ul>
                <p><strong>Files:</strong> sound/core/, sound/soc/, sound/pci/, sound/usb/</p>
            </div>

            <div class="info-card">
                <h2>üì± Input/Output Subsystem</h2>
                <p>
                    Unified input and output system that handles all user interface devices,
                    from keyboards and mice to touchscreens and sensors.
                </p>
                <h3>Device Types:</h3>
                <ul class="feature-list">
                    <li><strong>HID (Human Interface Devices):</strong> Keyboards, mice, gamepads</li>
                    <li><strong>Touchscreens:</strong> Capacitive and resistive touchscreens</li>
                    <li><strong>Sensors:</strong> Accelerometers, gyroscopes, magnetometers</li>
                    <li><strong>Haptic Feedback:</strong> Vibration and tactile feedback</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Multi-touch support</li>
                    <li>Gesture recognition</li>
                    <li>Accessibility features</li>
                    <li>Automatic hot-plugging</li>
                    <li>Device power management</li>
                </ul>
                <p><strong>Files:</strong> drivers/input/, drivers/hid/, drivers/iio/</p>
            </div>

        </section>

        <section id="contributors" class="section">
            <h1 class="titulo-principal">Contributors</h1>
            <div class="info-card">
                <p>
                    Special thanks to all the people who have contributed to the development of IR0.
                </p>
                <div id="contributors-grid" class="contributors-grid">
                    <!-- Contributors will be loaded here -->
                </div>
            </div>
        </section>

        <section id="descarga" class="section">
            <h1 class="titulo-guia">Downloads</h1>

            <div class="info-card">
                <p>
                    <li>The kernel binary download will be available in this section when the first stable version of
                        the mainline branch is released.</li>
                </p>


            </div>
        </section>
    </div>

    <script src="contributors.js"></script>
</body>

</html>