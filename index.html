<!DOCTYPE html>
<html lang="es">
<!-- Si est√°s leyendo esto, primero ya te dije que no estoy usando ning√∫n framework de moda hipster como React, next, nest, lo que sea. A lo sumo Blazor. -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/Assets/cuatro-nucleos.png" type="image/x-icon">
    <title>IR0 Kernel - Wiki</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <script src="main.js"></script>

    <nav class="navbar">
        <div class="nav-container">
            <div class="logo"><a href="index.html" target="_blank" rel="noopener noreferrer"
                    style="text-decoration: none; color: white;">IR0 Wiki</a></div>
            <ul class="nav-menu">
                <li><a href="#overview" class="nav-link active" onclick="showSection('overview')">Inicio</a></li>
                <li><a href="#architecture" class="nav-link" onclick="showSection('architecture')">Arquitectura</a></li>
                <li><a href="#branches" class="nav-link" onclick="showSection('branches')">Ramas</a></li>
                <li><a href="#development" class="nav-link" onclick="showSection('development')">Desarrollo</a></li>
                <li><a href="#panic" class="nav-link" onclick="showSection('panic')">Subsistemas</a></li>
                <li><a href="#overview" class="nav-link" onclick="showSection('descarga')">Descarga</a></li>
                <li class="language-dropdown">
                    <button class="translate-btn" onclick="toggleLanguageMenu()">üåê ES</button>
                    <div class="language-menu" id="languageMenu">
                        <a href="index.html" class="language-option active">üá™üá∏ Espa√±ol</a>
                        <a href="index_en.html" class="language-option">üá∫üá∏ English</a>
                    </div>
                </li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <section id="overview" class="section active">
            <h1 class="titulo-principal">IR0 Kernel - Overview</h1>

            <div class="info-card">
                <p>
                    El prop√≥sito de esta "wiki", documentaci√≥n web, gu√≠a, como le digas, es usarla como ayuda-memoria
                    personal
                    para el desarrollo del kernel.
                    No tiene que ser una p√°gina ultra est√©tica, pero me estoy esforzando para que no se note que la hice
                    con html, css y js vanilla como la de <a href="https://docs.kernel.org/" target="_blank"
                        rel="noopener noreferrer">alg√∫n proyecto aficionado</a>
                    que anda por ah√≠. <br> <br>
                    Un kernel de sistema operativo m√≠nimamente funcional (todo el <a
                        href="https://en.wikipedia.org/wiki/User_space_and_kernel_space" target="_blank"
                        rel="noopener noreferrer">Kernel Space</a> m√°s un user space m√≠nimo)
                    puede andar f√°cilmente en las <strong>15.000</strong> l√≠neas de c√≥digo por lo que, como ver√°s;
                    es humanamente imposible memorizar y comprender todo el flujo del kernel por m√≠ mismo. Adem√°s son
                    muchos subsistemas complejos trabajando a bajo nivel juntos para intermediar entre hardware y
                    software.
                </p>
            </div>


            <div class="info-card">
                <h2>¬øQu√© es IR0?</h2>
                <p>
                    <strong>IR0</strong> es un <strong>kernel de sistema operativo multiprop√≥sito</strong> desarrollado
                    desde cero para arquitectura
                    <strong>x86-64</strong> escrito principalmente en <strong>C</strong> y <strong>ASM</strong> (Aunque
                    no tengo ning√∫n problema en incluir c√≥digo de otros lenguajes especializados en performance como
                    <strong>Cpp</strong> o <strong>Rust</strong>).
                    <br>
                    Lo estoy creando para aprender m√°s sobre sistemas operativos y poder usarlo como materia
                    prima para otro proyecto que replica a <a href="https://learn.microsoft.com/es-es/windows/wsl/about"
                        target="_blank" rel="noopener noreferrer">WSL2</a> pero con mi propio kernel.
                    No descarto escalarlo lo suficiente como para hacerlo usable en servidores m√≠nimos o incluso IoT,
                    pero entiendo que eso es al largo <i>(largu√≠simo)</i> plazo.
                    <br>
                    <br>
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank" rel="noopener noreferrer">Este
                        es su Repositorio de GitHub.</a>
                </p>
            </div>


            <div class="info-card">
                <h2>Caracter√≠sticas Principales y las futuras</h2>
                <ul class="feature-list">
                    <li>Kernel monol√≠tico para arquitectura x86-64</li>
                    <li>Gesti√≥n de memoria con paging en esas dos arquitecturas</li>
                    <li>Manejo de interrupciones y excepciones</li>
                    <li>Bootloader personalizado (S√≥lo en x86 y seg√∫ramente migre todas las arquitecturas a GRUB)</li>
                    <li>El c√≥digo ensamblador que uso es en sintaxis de <a
                            href="https://cs.lmu.edu/~ray/notes/nasmtutorial/" target="_blank"
                            rel="noopener noreferrer">Intel Netwide Assembler (nasm)</a>.</li>
                    <li>Filesystem propio basado en EXT con optimizaci√≥n con bbdd vectorial en espacio de usuario</li>
                    <li>Pila de red y <a href="https://opensource.com/article/22/12/linux-abi" target="_blank"
                            rel="noopener noreferrer">ABI</a> prestados de Linux (Son millones de l√≠neas de c√≥digo que
                        no pienso escribir solo)</li>
                    <li>Syscalls propias y algunas mapeadas de Linux</li>
                    <li>Algunos drivers para manejo de hardware m√≠nimo.</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>Estado del Proyecto</h2>
                <p><strong>Versi√≥n:</strong> no versionado a√∫n (pero vamos a decir pre-release por ahora.)<br>
                    <strong>Arquitectura:</strong> x86-64 (i386)<br>
                    <strong>Bootloader:</strong> GRUB<br>
                    <strong>Sintaxis ASM:</strong> Intel
                </p>
            </div>
        </section>

        <section id="architecture" class="section">
            <h1 class="titulo-principal">Arquitectura del Sistema</h1>

            <div class="architecture-box">
                <img src="Assets/scheme-core.png" alt="ir0-arch" srcset="">
            </div>
            <div class="info-card">
                <h2>Arquitectura y "Filosof√≠a" del proyecto</h2>
                <p>
                    A diferencia de kernels como <a href="https://en.wikipedia.org/wiki/Windows_NT" target="_blank"
                        rel="noopener noreferrer">kernel NT (H√≠brido)</a> de Microsoft, <a
                        href="https://www.redox-os.org/" target="_blank" rel="noopener noreferrer">Redox-OS
                        (Microkernel)</a>,
                    o el mismo <a href="https://es.wikipedia.org/wiki/MINIX" target="_blank"
                        rel="noopener noreferrer">MINIX kernel (microkernel)</a>, IR0 se basa en una arquitectura m√°s
                    similar a la que tiene Linux, que es monol√≠tico.
                    <br>

                    Sin embargo, mi argumento principal es el del rendimiento. Entiendo que alguien podr√≠a venir y
                    se√±alar que, como todo monolito, si un subcomponente se rompe, se cae todo el sistema <small>(y
                        tendr√≠a raz√≥n)</small>
                    pero lo que respondo a eso es que <i>"¬øDe qu√© me sirve a m√≠ que el kernel soporte seguir sin
                        filesystem si no puedo hacer nada pr√°ctico sin √©l?"</i>, es decir, no tiene sentido que el
                    kernel
                    contin√∫e funcionando <strong>sin uno de sus componentes clave corriendo</strong>. <br><br>

                    Por eso no veo mejor alternativa (por ahora) que el patr√≥n <a
                        href="https://es.wikipedia.org/wiki/N%C3%BAcleo_monol%C3%ADtico" target="_blank"
                        rel="noopener noreferrer">monol√≠tico</a>. Y adem√°s me ahorra el tener que interconectar
                    subsistemas clave entre s√≠ con IPC, lo que impacta de una en el rendimiento del Sistema Operativo.
                    No es
                    perfecto, pero es estable. No es del todo trazable y requiere escalar de a poco, pero si escala bien
                    rinde mucho. <br>

                    <br>
                    Sin embargo yo tambi√©n tengo desacuerdos con la <a
                        href="https://es.wikipedia.org/wiki/Filosof%C3%ADa_de_Unix" target="_blank"
                        rel="noopener noreferrer">filosof√≠a UNIX</a>. Ellos (entre otras cosas y de forma resumid√≠sima)
                    consideran
                    que si algo falla, <i>que falle bien</i>. Lo que en t√©rminos kernel√≠sticos ser√≠a: <i>Si se rompe el
                        scheduler, Panic() directo. Si ten√©s corrupci√≥n en memoria (en espacio de kernel),
                        Panic.</i><br>
                    Y no es que lo cuestiono por que s√≠, simplemente pregunto (aunque sin soluciones todav√≠a) <i>"¬øPor
                        qu√© no rescatar el sistema en tiempo de Panic()?, o por lo menos hacer el intento"</i>. <br>
                    Mas all√° del punto filos√≥fico y para resumir, el kernel es monol√≠tico porque es m√°s performante y
                    siento que las piezas clave del n√∫cleo deben <strong>trabajar sin overhead</strong>. <br>
                    Sin embargo, si en el futuro necesitara integrar alg√∫n subsistema espec√≠fico de forma h√≠brida,
                    seguramente ser√≠a pragm√°tico.
                </p>
                <h2>El Kernel Space es sagrado</h2>
                <p>
                    Yo s√© que hablo como si IR0 fuera usado por miles de personas y toda la historia, pero me voy a dar
                    el lujo de opinar al respecto.
                    <br>Entonces, el punto es que el kernel space <strong>tiene que ser s√≥lo habitable por subsistemas
                        que trabajen en ese Entorno</strong>,
                    nada mas. <br>
                    Entiendo que hayan ciertos <a
                        href="https://www.reddit.com/r/riotgames/comments/1gxhfmh/the_future_of_riot_vanguard_and_kernel_level/"
                        target="_blank" rel="noopener noreferrer">fabricantes preocupados por la seguridad de sus
                        clientes</a> que,
                    casualmente, tienen acceso a <i>toda interrupci√≥n que el usuario haga (saben qu√© teclas presion√°s,
                        el tiempo de tu sesi√≥n cada vez que prend√©s la compu, etc.)</i> Y todo eso porque tienen
                    software funcionando en el <a href="https://en.wikipedia.org/wiki/User_space_and_kernel_space"
                        target="_blank" rel="noopener noreferrer">kernel space</a> con todos los privilegios que eso
                    implica.
                    <br> <a href="https://en.wikipedia.org/wiki/Protection_ring" target="_blank"
                        rel="noopener noreferrer">RING 0</a> es √∫nicamente para el kernel. Todo lo que venga del RING 3
                    se comunica con <i>syscalls()</i>, fin del comunicado.
                </p>
                <h2>Qu√© le pido prestado a Linux?</h2>
                <p>
                    Si pretendo hacer que IR0 funcione como soporte para servidores (backends, juegos, etc), que pueda
                    correr docker y kubernetes (al menos) y que, en alg√∫n momento,
                    pueda funcionar como base para IoT, necesito tener en primer lugar <strong>soporte de red, con sus
                        drivers, soporte de protocolos de red modernos</strong> mas <strong>todos los algoritmos que
                        implementan internamente</strong>.
                    <br><br>
                    En el Kernel Linux son mas o menos <i>1.500.000</i> de l√≠neas de c√≥digo <strong>S√ìLO LA PILA DE RED
                        COMPLETA</strong>.
                    <br>
                    Literal, si quisiera levantarla de cero, a lo mejor pasar√≠a una d√©cada y no estar√≠a lista. No me
                    siento tan zarpado la verdad.
                    <br><br>
                    Te muestro como ser√≠a lo que necesito de la pila de red:
                    <br><br>
                    <img src="/Assets/deepseek_mermaid_20250808_234e4e.png" alt="chiquita la pilita de red" srcset=""
                        style="width: 50%;">
                    <br>
                    <small><i>Enti√©dase hardware como los componentes de tu <a
                                href="https://es.wikipedia.org/wiki/Placa_base" target="_blank"
                                rel="noopener noreferrer"></a>MOBO</i> que hablan con el kernel.
                        Aparte, ac√° se ve clarito como el kernel intermedia entre el hard y el soft.</small>
                    <br><br>

                    El mismo asunto tenemos con el <strong>soporte para contenedores</strong>. Ac√° el tema es un toque
                    m√°s tranqui porque son un par menos de l√≠neas de c√≥digo en total: <i>unas 300.000 l√≠neas</i>
                    pero igual, como pasa con la pila de red, son dos proyectos totalmente aparte.
                    <br> <br>
                    Mas o menos esto es lo que requiere docker para andar, desde la app con su runtime, hasta sus
                    accesos en el kernel.
                    <br><br>
                    <img src="/Assets/docker.png" alt="" srcset="" style="width: 101%;">
                    <br>
                    <small>Fijate que docker necesita levantar literalmente un file system virtual, adem√°s de limitar la
                        cpu, acceder a RAM, tener una interfaz de red privada, usa los namespaces para aislar del
                        entorno su contenido, etc.
                    </small>
                    <br>
                <h2>C√≥mo lo voy a resolver?</h2>
                Bueno, si escribir la pila red y el soporte de contenedores no es trivial, integrarlos fuera de su
                entorno tampoco lo es, pero es mas humano que diagramar, implementar y testear.
                <br><br>
                Muy seguramente me toque mapear las syscalls que espera esa parte de Linux al estilo <a
                    href="https://es.wikipedia.org/wiki/Wine" target="_blank" rel="noopener noreferrer">Wine/Proton</a>,
                o copiarles algunas de las que usan
                nativamente si me sirven despu√©s.
                </p>

            </div>


            <div class="info-card">
                <h2>Estructura de Directorios</h2>
                <p>
                    C√≥mo la estructura de archivos puede cambiar constantemente, prefiero que la consultes en el
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank"
                        rel="noopener noreferrer">Repositorio de GitHub</a>.
                </p>

            </div>

        </section>

        <section id="branches" class="section">
            <h1 class="titulo-principal">Gesti√≥n de Ramas</h1>
            <div class="info-card">
                <h2>Flujo de Trabajo con Git</h2>
                <div class="code-block">
                    <article>Como es la primera vez que escribo un proyecto de este calibre, lo que busco
                        es que el Workflow para el desarrollo del kernel sea
                        lo mas limpio, predecible y escalable posible.
                        <br>
                        <br>
                        Para eso uso 3 ramas de git principales en el
                        proceso: mainline, dev y feature (que aunque feature no est√° en el repositorio, es la que se usa
                        como convenci√≥n para
                        integrar c√≥digo nuevo).
                        Donde s√≥lo <strong>mainline</strong> y <strong>dev</strong> son las √∫nicas 2 <i>ramas
                            upstream</i>.
                        <br>
                        <br>
                        <strong>experimental</strong> es una rama
                        divergente a <strong>dev</strong>, y <strong>feature</strong> es la rama que se crea para enviar
                        contribuciones.
                    </article>
                </div>
            </div>

            <!-- mainline BRANCH -->
            <div class="branch-grid">
                <div class="branch-card">
                    <div class="branch-title">mainline</div>
                    <div class="status-badge status-stable">STABLE</div>
                    <p><strong>-</strong> Rama principal con c√≥digo estable y testeado.</p>

                    <h3>Caracter√≠sticas</h3>
                    <ul class="feature-list">
                        <li>Solo c√≥digo probado y funcional</li>
                        <li>Documentaci√≥n completa</li>
                        <li>Mi base para rc's.</li>
                        <li><strong>mainline es sagrada</strong>, ya que este rama <strong>tiene que compilar y bootear
                                siempre</strong>. Es la mas
                            estable de las
                            dos ramas upstream.
                        </li>
                    </ul>

                </div>
                <!-- DEV BRANCH -->
                <div class="branch-card">
                    <div class="branch-title">dev</div>
                    <div class="status-badge status-development">STAGING</div>
                    <p><strong>-</strong> Rama de desarrollo activo donde se implementan y testean nuevas
                        features.
                    </p>

                    <h3>Caracter√≠sticas:</h3>
                    <ul class="feature-list">
                        <li>Es el espejo de <strong>mainline</strong>.</li>
                        <li>Lo que se mergee ac√° no tiene por qu√© pasar a <strong>mainline</strong>.</li>
                        <li>Nuevas features en desarrollo que me convencieron de feature</li>
                        <li>Parches de c√≥digo, refactors y optimizaciones</li>
                        <li>Puede contener bugs temporales que se resuelven s√≠ o s√≠ en esta rama.</li>
                    </ul>

                </div>



                <!-- feat BRANCH -->
                <div class="branch-card">
                    <div class="branch-title">feature</div>
                    <div class="status-badge status-feat">DEVELOPMENT</div>
                    <p><strong>-</strong>
                        La agrego porque es la rama donde se crean feats que despues pasan al upstream
                        mergeando a <strong>dev</strong> . Es la m√°s inestable de todas porque es donde se integra
                        c√≥digo nuevo que tambi√©n debe ser testeado y revisado antes de llegar a merge.
                    </p>

                    <h3>Caracter√≠sticas:</h3>
                    <ul class="feature-list">
                        <li>Ac√° es donde yo empiezo a implementar nuevas funcionalidades o parches</li>
                        <li>Es la primera que se debuggea.</li>
                        <li>Es la que crear√≠as cuando forke√°s el repo.</li>
                        <li>Se espera que compile antes de pasar a <strong>dev</strong>.</li>
                    </ul>
                </div>
                <!-- exp BRANCH -->

                <div class="branch-card">
                    <div class="branch-title">experimental</div>
                    <div class="status-badge status-exp">MISC</div>
                    <p><strong>-</strong>
                        En esta rama, se integran features lo suficientemente inestables como para terminar en
                        <strong>mainline</strong>
                        pero que pueden tener potencial a futuro.
                    </p>

                    <h3>Caracter√≠sticas:</h3>
                    <ul class="feature-list">
                        <li>Es una rama de pruebas puras, no tiene nada que ver con las ramas upstream estables</li>
                        <li>Ac√° caen las features y experimentos que no llegan al <strong>mainline</strong></li>
                        <li>Cosas que no se prueban en sistemas operativos o ideas nuevas</li>
                        <li>No es tan importante la estabilidad en esta rama</li>
                        <li>Si se testean lo suficiente sin romper nada, pueden o no mergear a mainline primero
                            pasando por <strong>dev</strong> de nuevo.
                        </li>
                    </ul>
                </div>

            </div>


            <div class="info-card">
                <h2>C√≥mo es el merging desde feature hasta mainline?</h2>

                <article>
                    B√°sicamente, vos cre√°s tu mejora/optmizaci√≥n <strong>desde un fork del repo con una rama
                        nueva</strong> que va a ser algo como <i>"feature/fix-scheduler"</i> por ejemplo. <br>
                    Despu√©s, <strong>hac√©s PR a la rama dev del upstream (no al mainline)</strong> y se hace la revisi√≥n
                    y el merge en dado caso. <br>
                    El merge a mainline depende de <strong>cu√°n alineado con el proyecto considere que es la
                        feature</strong>. <br>
                    Ni siquiera algunas de mis propias implementaciones las mergear√≠a directo al mainline por esta misma
                    raz√≥n.
                </article>

            </div>



        </section>

        <section id="development" class="section">
            <h1 class="titulo-guia">Gu√≠a de Desarrollo</h1>

            <div class="info-card">
                <p>
                <div class="code-block">
                    <strong>-</strong> Esta secci√≥n es por si alguien se interesa en contribuir al proyecto. <strong>No
                        son
                        reglas estrictas, son simplemente recomendaciones
                        para que sea mas llevadero.</strong>
                </div>
                </p>
                <h2>¬øQu√© hay que saber para contribuir?</h2>
                M√°s que nada lo siguiente:
                <li>Saber programaci√≥n estructurada/funcional/orientada a objetos seg√∫n sea necesario por el lenguaje.
                </li>
                <li>Conocer C o C++ o Rust.</li>
                <li>Assembly si contribu√≠s en subsistemas muy pegados al hard, pero recomiendo conocer los b√°sicos para
                    saber c√≥mo funcionan <i>panic(), boot.asm, etc.</i></li>
                <li><strong>Conocer c√≥mo funciona un makefile</strong>, como compilar los subsistemas por partes, por
                    qu√©
                    hay que compilar los subsistemas por separado con su propio makefile</li>
                <li><strong>Herramientas de desarrollo general</strong>: GIT/GitHub, como crear, cambiar, pullear y
                    lanzar
                    PR's entre ramas</li>
                <li><strong>QEMU b√°sico.</strong> C√≥mo funciona la VM, como se le carga la imagen generada al compilar
                    el
                    kernel.</li>
                <li><strong>Conocer Bash es un plus para los testeos r√°pidos</strong>, ya que pod√©s iniciar QEMU con un
                    script sin repetir el comando completo.</li>
                <li>Comunicaci√≥n. <strong>Argumentar decisiones sobre las PR's</strong>, debatir sanamente al respecto.
                </li>
                <li>Saber utilizar IA's en general para optimizar el debug y adaptarlo a las convenciones de c√≥digo.
                </li>
                <li>Saber que, al contribuir, <strong>pod√©s ser manteiner del subsistema al que aportaste</strong>. Y si
                    no
                    pod√©s dar mantenimiento
                    recurrente al subsistema, <strong>dejarlo bien documentado</strong>.</li>
                <br>
                    De igual forma, <strong>no hay que ser un experto para contribuir al kernel. Simplemente con tener ganas
                    de
                    aprender/estudiar sobre lo que vayas a contribuir es m√°s que suficiente</strong>.

                <h2>Configuraci√≥n del Entorno</h2>
                <h3>Dependencias Requeridas:</h3>
                <li>B√°sicamente tener instalado: el compilador de C/Cpp (gcc/g++), el compilador de asm (nasm), make
                    para la
                    compilaci√≥n y
                    QEMU como vm de prueba.
                </li>
                Te dar√≠a los comandos o las webs para instalar, pero chatgpt te lo puede resolver mejor.
                <br><br>

                <div class="code-block">
                    <strong>NOTA</strong>: Como este proyecto es un kernel, es <i>Freestanding</i>. Eso quiere decir que
                    vos
                    <strong>no pod√©s incluir librer√≠as como
                        stdio.h para hacer un <code>print(), write()</code>, etc. por que no hay sistema operativo que
                        responda a esas funciones </strong>. <strong>Vos sos el
                        sistema operativo</strong>. por eso, en el repo tengo la carpeta de dependencias "includes".
                    </strong>
                </div>

            </div>
            <div class="info-card">
                <h2>C√≥mo escribo c√≥digo?</h2>
                <h3>Convenciones de Nombres:</h3>
                <ul class="feature-list">
                    <li>Funciones: <code>snake_case()</code></li>
                    <li>Macros: <code>UPPER_CASE</code></li>
                    <li>Structs: <code>struct_name_t</code></li>
                    <li>Variables globales: <code>g_variable_name</code></li>
                    <li>Constantes: <code>CONSTANT_NAME</code></li>
                    <li>includes: <code>#INCLUDE -ir0/Lib.h - </code>(se estan migrando a ese formato)</li>
                </ul>
                <h3>Comentarios:</h3>
                <ul class="feature-list">
                    <li>archivos de encabezado .h de funciones documentadas</li>
                    <li>Archivos de c√≥digo fuente con comentarios en algunas funciones, pero mas acotados</li>
                    <li>Explicaci√≥n de algoritmos complejos</li>
                    <li>TO DO's claramente marcados</li>
                    <li>Referencias a documentaci√≥n t√©cnica</li>
                </ul>
                <small>Esto es aproximado. Por lo general trato de respetar esas convenciones lo m√°ximo que
                    puedo.</small>
                <br><br>
                <li>Algo as√≠ ser√≠a en este ejemplo una archivo promedio de c√≥digo fuente:</li>
                <br>
                <img src="/Assets/funcion.c.png" alt="" srcset="" style="width: 50%;">
                <br>
                <i>Fijate en c√≥mo uso las llaves por debajo del nombre de la funcion y los mismo en condicionales,
                    bucles,
                    etc. Tambi√©n como directamente no las uso cuando el condicional tiene una sola l√≠nea
                    o hay cierto nesting.</i>
                <br>
                <br>
                <li>As√≠ manejo los encabezados (o la mayor√≠a):</li>
                <br><br>
                <img src="/Assets/encabezado.png" alt="" srcset="">
                <br>
                <i>Los comentarios grandes van por lo general en √©stos .h y en los fuente hacemos acotaciones.</i>
            </div>

            <div class="info-card">
                <h2>C√≥mo compilar (por ahora)</h2>
                <div class="code-block">
                    <li>Tiene que haber un makefile en todos los subsistemas, por lo que se deber√≠a poder hacer <i>make
                            "subsistema"</i></li> <br>
                    <li>Despu√©s, el kernel tiene un makefile general para generar el binario, con su clean respectivo.
                        Por
                        ahora se usa as√≠: <i>make all</i></li> <br>
                    <li>A futuro, seguramente hayan estrategias de compilaci√≥n que permitan compilar el kernel entero
                        para
                        sus distintos usos.</li>
                </div>
            </div>
        </section>

        
        <section id="panic" class="section">
            <h1 class="titulo-guia">Subsistemas del kernel</h1>
            <div class="code-block">
                <p>
                    <strong>-</strong> No hay mucha ciencia ac√°. Simplemente doy una revisi√≥n de los subsistemas y
                    algunas
                    features a desarrollar
                    a futuro.
                    <br>
                    <br>

                    Igual, la mejor forma de interiorizarse sobre el funcionamiento del kernel, es viendo el c√≥digo del
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank"
                        rel="noopener noreferrer" class="link-repo">Repositorio de GitHub</a>.
                </p>
            </div>


            <div class="info-card">
                <h2>Scheduler</h2>
                <p>
                    Por ahora es un <a href="https://en.wikipedia.org/wiki/Round-robin_scheduling" target="_blank"
                        rel="noopener noreferrer">Round-Robin</a> simple. La idea es usarlo como fallback ya que el
                    sched
                    principal deber√≠a ser preemptivo
                    y usa un esquema de prioridad simple (CFS o algo as√≠).
                    <br>
                    <br>
                    <strong>Archivos:</strong> scheduler/scheduler.c, scheduler/task.h, scheduler/switch/switch.asm.
                </p>
                <br>



            </div>

            <div class="info-card">
                <h2>Filesystem</h2>
                <p>
                    Basado en <a href="https://es.wikipedia.org/wiki/Ext2" target="_blank"
                        rel="noopener noreferrer">EXT2</a> y hecho desde cero. La √∫nica innovaci√≥n
                    ser√≠a incluir optimizacion en funciones de b√∫squeda con una <a
                        href="https://github.com/victor-base/libvictor" target="_blank" rel="noopener noreferrer">lib de
                        bbdd vectorial</a>
                    en la que contribu√≠.
                    <br>
                    <br>

                    <strong>Archivos:</strong> A implementar.
                </p>
            </div>


            <div class="info-card">
                <h2>Sistema de Interrupciones</h2>
                <p>
                    IDT de 256 entradas, manejo de page faults, handlers y wrapper en ensamblador.
                    <br>
                    <br>

                    <strong>Archivos:</strong> interrupt/idt.c, interrupt/interrupt.asm, interrupt/isr_handlers.c con
                    sus
                    encabezados.
                </p>
            </div>

            <div class="info-card">
                <h2>Subsistema de arranque </h2>
                <p>
                    Arranque dependiendo de la arquitectura (X86_64) con punto de entrada en ASM.
                    <br>
                    <br>
                    

                    <img src="/Assets/diag.png" alt="diagramar" srcset="" style="width: 100%;">
                    <strong>Archivos:</strong> boot.asm, kmain.c arch.c, kernel_start.c.
                </p>
            </div>



        </section>

        <section id="descarga" class="section">
            <h1 class="titulo-guia">Descargas</h1>

            <div class="info-card">
                <p>
                    <li>La descarga del binario del kernel se expondr√° en esta secci√≥n cuando salga la primer versi√≥n
                        estable de la rama <strong>mainline</strong>.</li>
                </p>
                
            </div>
        </section>
    </div>

</body>

</html>