<!DOCTYPE html>
<html lang="en">
<!-- If you're reading this, first I already told you that I'm not using any trendy hipster framework like React, next, nest, whatever. At most Blazor. -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/Assets/cuatro-nucleos.png" type="image/x-icon">
    <title>IR0 Kernel - Wiki</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@300;400;500;700&family=Ubuntu+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <script src="main.js"></script>

    <nav class="navbar">
        <div class="nav-container">
            <div class="logo"><a href="index_en.html" target="_blank" rel="noopener noreferrer"
                    style="text-decoration: none; color: white;">IR0 Wiki</a></div>
            <ul class="nav-menu">
                <li><a href="#overview" class="nav-link active" onclick="showSection('overview')">Home</a></li>
                <li><a href="#architecture" class="nav-link" onclick="showSection('architecture')">Architecture</a></li>
                <li><a href="#branches" class="nav-link" onclick="showSection('branches')">Branches</a></li>
                <li><a href="#development" class="nav-link" onclick="showSection('development')">Development</a></li>
                <li><a href="#subsystems" class="nav-link" onclick="showSection('subsystems')">Subsystems</a></li>
                <li><a href="#overview" class="nav-link" onclick="showSection('descarga')">Download</a></li>
                <li class="language-dropdown">
                    <button class="translate-btn" onclick="toggleLanguageMenu()">üåê EN</button>
                    <div class="language-menu" id="languageMenu">
                        <a href="index.html" class="language-option">üá™üá∏ Espa√±ol</a>
                        <a href="index_en.html" class="language-option active">üá∫üá∏ English</a>
                    </div>
                </li>
                <li><button id="darkModeBtn" class="dark-mode-btn" onclick="toggleDarkMode()">üåô</button></li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <section id="overview" class="section active">
            <h1 class="titulo-principal">IR0 Kernel - Overview</h1>

            <div class="info-card">
                <p>
                    The purpose of this "wiki", web documentation, guide, however you call it, is to use it as a personal memory aid
                    for kernel development.
                    It doesn't have to be an ultra-aesthetic page, but I'm trying hard so it doesn't show that I made it
                    with vanilla html, css and js like some amateur project
                    that's out there. <br> <br>
                    A minimally functional operating system kernel (all the <a
                        href="https://en.wikipedia.org/wiki/User_space_and_kernel_space" target="_blank"
                        rel="noopener noreferrer">Kernel Space</a> plus a minimal user space)
                    can easily run in <strong>15,000</strong> lines of code, so as you'll see;
                    it's humanly impossible to memorize and understand the entire kernel flow by myself. Besides, there are many complex subsystems working together at a low level to mediate between hardware and software.
                </p>
            </div>

            <div class="info-card">
                <h2>What is IR0?</h2>
                <p>
                    <strong>IR0</strong> is a <strong>multipurpose operating system kernel</strong> developed
                    from scratch for <strong>x86-64</strong> architecture written primarily in <strong>C</strong> and <strong>ASM</strong> (Although
                    I have no problem including code from other specialized languages in performance such as
                    <strong>Cpp</strong> or <strong>Rust</strong>).
                    <br>
                    I'm creating it to learn more about operating systems and be able to use it as raw material
                    for another project that replicates <a href="https://learn.microsoft.com/es-es/windows/wsl/about"
                        target="_blank" rel="noopener noreferrer">WSL2</a> but with my own kernel.
                    I don't rule out scaling it enough to make it usable in minimal servers or even IoT,
                    but I understand that's in the very long term.
                    <br>
                    <br>
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank" rel="noopener noreferrer">This
                        is its GitHub Repository.</a>
                        <br>
                    <a href="https://discord.gg/XZ84aPXtxh" target="_blank" rel="noopener noreferrer">Discord community</a>                </p>
            </div>

            <div class="info-card">
                <h2>Main Implemented Features</h2>
                <ul class="feature-list">
                    <li>‚úÖ Monolithic modular kernel for x86-64 architecture</li>
                    <li>‚úÖ Complete virtual memory management with paging (MMU)</li>
                    <li>‚úÖ Complete interrupt and exception system (64 IDT vectors)</li>
                    <li>‚úÖ CFS (Completely Fair Scheduler) with Red-Black Tree</li>
                    <li>‚úÖ Complete process system with fork(), exit(), waitpid()</li>
                    <li>‚úÖ 23 implemented syscalls (from basic to memory management)</li>
                    <li>‚úÖ Complete MINIX filesystem with VFS (Virtual File System)</li>
                    <li>‚úÖ Hardware drivers: PS/2 (keyboard/mouse), ATA/IDE, Sound Blaster 16, VGA</li>
                    <li>‚úÖ Interactive shell in Ring 3 with built-in commands</li>
                    <li>‚úÖ Freestanding LibC with printf(), malloc(), free()</li>
                    <li>‚úÖ Multi-target build system (Desktop/Server/IoT/Embedded)</li>
                    <li>üîÑ Basic TCP/IP network stack (in development - using IoT library)</li>
                    <li>üîÑ Container support (in development)</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>Project Status</h2>
                <p><strong>Version:</strong> v0.0.1 pre-release candidate 1<br>
                    <strong>Architecture:</strong> x86-64 (primary), x86-32 (experimental), ARM (in development)<br>
                    <strong>Bootloader:</strong> GRUB<br>
                    <strong>License:</strong> GNU GPL v3.0<br>
                    <strong>Type:</strong> Monolithic Modular Kernel<br>
                    <strong>ASM Syntax:</strong> Intel (NASM)
                </p>
            </div>
        </section>

        <section id="architecture" class="section">
            <h1 class="titulo-principal">System Architecture</h1>

            <div class="architecture-box">
                <h3>IR0 Kernel Architecture Diagram</h3>
                <div class="kernel-architecture">
                    <!-- User Space -->
                    <div class="layer user-space">
                        <div class="layer-title">User Space (Ring 3)</div>
                        <div class="components">
                            <div class="component">Interactive Shell</div>
                            <div class="component">LibC (IR0)</div>
                            <div class="component">User Programs</div>
                            <div class="component">ELF Loader</div>
                        </div>
                    </div>
                    
                    <!-- Kernel Space -->
                    <div class="layer kernel-space">
                        <div class="layer-title">Kernel Space (Ring 0) - IR0</div>
                        <div class="kernel-components">
                            <!-- System Interface -->
                            <div class="kernel-section system-interface">
                                <div class="section-title">System Interface</div>
                                <div class="component">23 Syscalls (IR0)</div>
                                <div class="component">INT 0x80 Handler</div>
                                <div class="component">Init System (PID 1)</div>
                            </div>
                            
                            <!-- Process & Memory -->
                            <div class="kernel-section core-subsystems">
                                <div class="section-title">Process & Memory</div>
                                <div class="component">CFS Scheduler</div>
                                <div class="component">Virtual Memory (MMU)</div>
                                <div class="component">Heap Allocator</div>
                                <div class="component">Process Manager</div>
                            </div>
                            
                            <!-- File System -->
                            <div class="kernel-section compatibility-section">
                                <div class="section-title">File System</div>
                                <div class="component">VFS Layer</div>
                                <div class="component">MINIX Filesystem</div>
                                <div class="component">File Operations</div>
                            </div>
                            
                            <!-- Hardware Drivers -->
                            <div class="kernel-section hardware-abstraction">
                                <div class="section-title">Hardware Drivers</div>
                                <div class="component">PS/2 (Keyboard/Mouse)</div>
                                <div class="component">ATA/IDE Storage</div>
                                <div class="component">Sound Blaster 16</div>
                                <div class="component">VGA/VBE Video</div>
                            </div>

                            <!-- Interrupts & Timers -->
                            <div class="kernel-section system-interface">
                                <div class="section-title">Interrupts & Timers</div>
                                <div class="component">IDT (64 vectors)</div>
                                <div class="component">PIC Remapping</div>
                                <div class="component">Timer Cascade</div>
                                <div class="component">DMA Controller</div>
                            </div>

                            <!-- Network (Planned) -->
                            <div class="kernel-section core-subsystems">
                                <div class="section-title">Network (In Development)</div>
                                <div class="component">Basic TCP/IP (IoT)</div>
                                <div class="component">Socket Interface</div>
                                <div class="component">Ethernet Drivers</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Hardware -->
                    <div class="layer hardware">
                        <div class="layer-title">Hardware</div>
                        <div class="components">
                            <div class="component">CPU x86-64</div>
                            <div class="component">RAM (MMU)</div>
                            <div class="component">ATA/IDE Disks</div>
                            <div class="component">PS/2 Devices</div>
                            <div class="component">Sound Blaster</div>
                            <div class="component">VGA/VBE</div>
                        </div>
                    </div>
                </div>
                
                <!-- Legend -->
                <div class="architecture-legend">
                    <div class="legend-item">
                        <div class="legend-color user-space-color"></div>
                        <span>User Space (Ring 3) - Shell, LibC and user programs</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color kernel-space-color"></div>
                        <span>Kernel Space (Ring 0) - IR0 monolithic modular kernel</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color hardware-color"></div>
                        <span>Hardware - Supported physical components</span>
                    </div>
                </div>
            </div>
            <div class="info-card">
                <h2>Architecture and "Philosophy" of the project</h2>
                <p>
                    Unlike kernels such as <a href="https://en.wikipedia.org/wiki/Windows_NT" target="_blank"
                        rel="noopener noreferrer">Microsoft's NT kernel (Hybrid)</a>, <a
                        href="https://www.redox-os.org/" target="_blank" rel="noopener noreferrer">Redox-OS
                        (Microkernel)</a>,
                    or the same <a href="https://es.wikipedia.org/wiki/MINIX" target="_blank"
                        rel="noopener noreferrer">MINIX kernel (microkernel)</a>, IR0 is based on a more similar architecture
                    to what Linux has, which is monolithic.
                    <br>

                    However, my main argument is that of performance. I understand that someone could come and
                    point out that, like any monolith, if a subcomponent breaks, the entire system crashes <small>(and
                        they would be right)</small>
                    but what I respond to that is <i>"What good does it do me that the kernel supports continuing without
                        filesystem if I can't do anything practical without it?"</i>, that is, it doesn't make sense that the
                    kernel
                    continues functioning <strong>without one of its key components running</strong>. <br><br>

                    That's why I don't see a better alternative (for now) than the <a
                        href="https://es.wikipedia.org/wiki/N%C3%BAcleo_monol%C3%ADtico" target="_blank"
                        rel="noopener noreferrer">monolithic</a> pattern. And it also saves me from having to interconnect
                    key subsystems with each other via IPC, which impacts performance of the Operating System. It's not
                    perfect, but it's stable. It's not entirely traceable and requires scaling little by little, but if it scales well it performs a lot. <br>

                    <br>
                    However, I also have disagreements with the <a
                        href="https://es.wikipedia.org/wiki/Filosof%C3%ADa_de_Unix" target="_blank"
                        rel="noopener noreferrer">UNIX philosophy</a>. They (among other things and very briefly)
                    consider
                    that if something fails, <i>let it fail well</i>. Which in kernel terms would be: <i>If the scheduler breaks, Panic() directly. If you have memory corruption (in kernel space),
                        Panic.</i><br>
                    And it's not that I question it for no reason, I simply ask (although without solutions yet) <i>"Why not rescue the system during Panic()?, or at least try"</i>. <br>
                    Beyond the philosophical point and to summarize, the kernel is monolithic because it's more performant and
                    I feel that the key pieces of the kernel must <strong>work without overhead</strong>. <br>
                    However, if in the future I needed to integrate some specific subsystem in a hybrid way,
                    I would surely be pragmatic.
                </p>
                <h2>Kernel Space is sacred</h2>
                <p>
                    I know I talk as if IR0 were used by thousands of people and all the history, but I'm going to give myself the luxury of opining
                    about it.
                    <br>So, the point is that kernel space <strong>has to be only habitable by subsystems
                        that work in that Environment</strong>,
                    nothing else. <br>
                    I understand that there are certain <a
                        href="https://www.reddit.com/r/riotgames/comments/1gxhfmh/the_future_of_riot_vanguard_and_kernel_level/"
                        target="_blank" rel="noopener noreferrer">manufacturers concerned about their clients' security</a> who,
                    coincidentally, have access to <i>every interruption that the user makes (they know what keys you press,
                        your session time every time you turn on the computer, etc.)</i> And all that because they have
                    software running in the <a href="https://en.wikipedia.org/wiki/User_space_and_kernel_space"
                        target="_blank" rel="noopener noreferrer">kernel space</a> with all the privileges that implies.
                    <br> <a href="https://en.wikipedia.org/wiki/Protection_ring" target="_blank"
                        rel="noopener noreferrer">RING 0</a> is only for the kernel. Everything that comes from RING 3
                    communicates with <i>syscalls()</i>, end of statement.
                </p>
                <h2>Network Approach: Basic but Functional</h2>
                <p>
                    For IR0 to work as support for basic servers and IoT applications, I need 
                    <strong>fundamental network support</strong> but without the massive complexity of Linux's complete stack.
                    <br><br>
                    In the Linux Kernel there are more or less <i>1,500,000</i> lines of code <strong>ONLY THE COMPLETE NETWORK STACK</strong>. Instead of trying to port all of that, I've decided to use a more pragmatic approach:
                    <br><br>
                    <strong>Basic implementation with IoT library:</strong>
                    <ul class="feature-list">
                        <li>Lightweight and functional TCP/IP stack</li>
                        <li>Support for basic network connectivity</li>
                        <li>Simplified socket interface</li>
                        <li>Essential Ethernet drivers</li>
                        <li>Minimalist approach that keeps the kernel manageable</li>
                    </ul>
                    This allows me to have network functionality without adding millions of lines of code to the kernel.

                <h2>Advantages of the Basic Approach</h2>
                This approach with IoT library has several advantages:
                <ul class="feature-list">
                    <li>Keeps the kernel lightweight and manageable</li>
                    <li>Significantly reduces code complexity</li>
                    <li>Allows network functionality without millions of additional lines</li>
                    <li>Easier to debug and maintain</li>
                    <li>Sufficient for basic use cases and IoT</li>
                </ul>
                </p>

            </div>

            <div class="info-card">
                <h2>Directory Structure</h2>
                <p>
                    How the file structure can change constantly, I prefer you consult it in the
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank"
                        rel="noopener noreferrer">GitHub Repository</a>.
                </p>

            </div>

        </section>

        <section id="branches" class="section">
            <h1 class="titulo-principal">Branch Management</h1>
            <div class="info-card">
                <h2>Git Workflow</h2>
                <div class="code-block">
                    <article>Since it's the first time I write a project of this caliber, what I'm looking for
                        is that the Workflow for kernel development be
                        as clean, predictable and scalable as possible.
                        <br>
                        <br>
                        For that I use 3 main git branches in the
                        process: mainline, dev and feature (which although feature is not in the repository, it's the one used as convention for
                        integrating new code).
                        Where only <strong>mainline</strong> and <strong>dev</strong> are the only 2 <i>upstream
                            branches</i>.
                        <br>
                        <br>
                        <strong>experimental</strong> is a branch
                        divergent to <strong>dev</strong>, and <strong>feature</strong> is the branch that is created to send
                        contributions.
                    </article>
                </div>
            </div>

            <!-- mainline BRANCH -->
            <div class="branch-grid">
                <div class="branch-card">
                    <div class="branch-title">mainline</div>
                    <div class="status-badge status-stable">STABLE</div>
                    <p><strong>-</strong> Main branch with stable and tested code.</p>

                    <h3>Characteristics</h3>
                    <ul class="feature-list">
                        <li>Only tested and functional code</li>
                        <li>Complete documentation</li>
                        <li>My base for rc's.</li>
                        <li><strong>mainline is sacred</strong>, since this branch <strong>has to compile and boot always</strong>. It's the most stable of the two upstream branches.
                        </li>
                    </ul>

                </div>
                <!-- DEV BRANCH -->
                <div class="branch-card">
                    <div class="branch-title">dev</div>
                    <div class="status-badge status-development">STAGING</div>
                    <p><strong>-</strong> Active development branch where new features are implemented and tested.
                    </p>

                    <h3>Characteristics:</h3>
                    <ul class="feature-list">
                        <li>It's the mirror of <strong>mainline</strong>.</li>
                        <li>What gets merged here doesn't have to go to <strong>mainline</strong>.</li>
                        <li>New features in development that convinced me of feature</li>
                        <li>Code patches, refactors and optimizations</li>
                        <li>It can contain temporary bugs that are resolved one way or another in this branch.</li>
                    </ul>

                </div>

                <!-- feat BRANCH -->
                <div class="branch-card">
                    <div class="branch-title">feature</div>
                    <div class="status-badge status-feat">DEVELOPMENT</div>
                    <p><strong>-</strong>
                        I add it because it's the branch where feats are created that later go to upstream
                        merging to <strong>dev</strong>. It's the most unstable of all because it's where new code is integrated that must also be tested and reviewed before reaching merge.
                    </p>

                    <h3>Characteristics:</h3>
                    <ul class="feature-list">
                        <li>This is where I start to implement new functionalities or patches</li>
                        <li>It's the first one that gets debugged.</li>
                        <li>It's the one you would create when you fork the repo.</li>
                        <li>It's expected to compile before going to <strong>dev</strong>.</li>
                    </ul>
                </div>
                <!-- exp BRANCH -->

                <div class="branch-card">
                    <div class="branch-title">experimental</div>
                    <div class="status-badge status-exp">MISC</div>
                    <p><strong>-</strong>
                        In this branch, features are integrated unstable enough to end up in
                        <strong>mainline</strong>
                        but that may have potential in the future.
                    </p>

                    <h3>Characteristics:</h3>
                    <ul class="feature-list">
                        <li>It's a pure testing branch, it has nothing to do with stable upstream branches</li>
                        <li>Here fall the features and experiments that don't reach <strong>mainline</strong></li>
                        <li>Things that aren't tested in operating systems or new ideas</li>
                        <li>Stability is not so important in this branch</li>
                        <li>If they are tested enough without breaking anything, they may or may not merge to mainline first
                            passing through <strong>dev</strong> again.
                        </li>
                    </ul>
                </div>

            </div>

            <div class="info-card">
                <h2>How is merging from feature to mainline?</h2>

                <article>
                    Basically, you create your improvement/optimization <strong>from a fork of the repo with a new branch</strong> that will be something like <i>"feature/fix-scheduler"</i> for example. <br>
                    Then, <strong>you make PR to the upstream dev branch (not to mainline)</strong> and the review and merge is done if applicable. <br>
                    The merge to mainline depends on <strong>how aligned with the project I consider the feature is</strong>. <br>
                    Not even some of my own implementations would I merge directly to mainline for this same reason.
                </article>

            </div>

        </section>

        <section id="subsystems" class="section">
            <h1 class="titulo-principal">IR0 Kernel Subsystems</h1>
            
            <div class="info-card">
                <h2>Project Status</h2>
                <p><strong>Version:</strong> v0.0.01 pre-release candidate 1<br>
                   <strong>Architecture:</strong> x86-64 (primary), x86-32 (experimental), ARM (in development)<br>
                   <strong>License:</strong> GNU GPL v3.0<br>
                   <strong>Type:</strong> Monolithic Modular Kernel</p>
            </div>

            <div class="info-card">
                <h2>üèóÔ∏è Core Architecture</h2>
                <h3>‚úÖ Kernel Architecture</h3>
                <ul class="feature-list">
                    <li>Monolithic modular design with HAL abstraction</li>
                    <li>Multi-target build system (Desktop/Server/IoT/Embedded)</li>
                    <li>Ring 0 (kernel) / Ring 3 (user) separation</li>
                    <li>x86-64 primary support with multi-arch framework</li>
                    <li>Freestanding C environment with custom libc</li>
                </ul>

                <h3>‚úÖ Boot System</h3>
                <ul class="feature-list">
                    <li>GRUB multiboot specification compliance</li>
                    <li>x86-64 long mode initialization</li>
                    <li>GDT (Global Descriptor Table) setup</li>
                    <li>TSS (Task State Segment) configuration</li>
                    <li>IDT (Interrupt Descriptor Table) with 64 entries</li>
                </ul>

                <h3>‚úÖ Memory Management</h3>
                <ul class="feature-list">
                    <li>Virtual memory with paging (MMU)</li>
                    <li>Kernel heap allocator (simple + advanced WIP)</li>
                    <li>Memory protection (Ring 0/3 isolation)</li>
                    <li>Memory layout: Kernel (1MB-8MB), Heap (8MB-32MB), User (1GB+)</li>
                    <li>Page fault handling with CR2 fault address reading</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>‚öôÔ∏è Process Management</h2>
                <h3>‚úÖ Process System</h3>
                <ul class="feature-list">
                    <li>Complete process lifecycle management</li>
                    <li>Process states: READY, RUNNING, BLOCKED, ZOMBIE</li>
                    <li>PID assignment starting from PID 1</li>
                    <li>Process creation with fork() syscall</li>
                    <li>Process termination with exit() syscall</li>
                    <li>Parent-child relationships with waitpid()</li>
                </ul>

                <h3>‚úÖ Scheduler</h3>
                <ul class="feature-list">
                    <li>CFS (Completely Fair Scheduler) implementation</li>
                    <li>Red-Black Tree runqueue for O(log n) operations</li>
                    <li>Virtual runtime (vruntime) tracking for fairness</li>
                    <li>Nice values support (-20 to +19)</li>
                    <li>Preemptive multitasking with timer integration</li>
                    <li>Context switching in optimized x86-64 assembly</li>
                </ul>

                <h3>‚úÖ Init System</h3>
                <ul class="feature-list">
                    <li>PID 1 init process (mini-systemd)</li>
                    <li>Service management and respawning</li>
                    <li>User mode switching from kernel</li>
                    <li>Shell service management</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üîß System Calls</h2>
                <h3>‚úÖ Syscall Interface (23 syscalls implemented)</h3>
                <div class="code-block">
                    <pre>SYS_EXIT(0)         - Process termination
SYS_WRITE(1)        - Write to file descriptor
SYS_READ(2)         - Read from file descriptor
SYS_GETPID(3)       - Get process ID
SYS_GETPPID(4)      - Get parent process ID
SYS_LS(5)           - List directory contents
SYS_MKDIR(6)        - Create directory
SYS_PS(7)           - Show process list
SYS_WRITE_FILE(8)   - Write file to filesystem
SYS_CAT(9)          - Display file contents
SYS_TOUCH(10)       - Create empty file
SYS_RM(11)          - Remove file
SYS_FORK(12)        - Create child process
SYS_WAITPID(13)     - Wait for child process
SYS_RMDIR(40)       - Remove directory
SYS_MALLOC_TEST(50) - Memory allocation test
SYS_BRK(51)         - Change heap break
SYS_SBRK(52)        - Increment heap break
SYS_MMAP(53)        - Memory mapping
SYS_MUNMAP(54)      - Unmap memory
SYS_MPROTECT(55)    - Change memory protection
SYS_EXEC(56)        - Execute program</pre>
                </div>

                <h3>‚úÖ Syscall Mechanism</h3>
                <ul class="feature-list">
                    <li>INT 0x80 software interrupt interface</li>
                    <li>Register-based parameter passing</li>
                    <li>Kernel/user mode transition</li>
                    <li>Error handling and return values</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>‚ö° Interrupt System</h2>
                <h3>‚úÖ Interrupt Handling</h3>
                <ul class="feature-list">
                    <li>Complete IDT setup with 64 interrupt vectors</li>
                    <li>PIC (Programmable Interrupt Controller) remapping</li>
                    <li>ISR (Interrupt Service Routines) in assembly</li>
                    <li>IRQ handling for hardware devices</li>
                    <li>Timer interrupt integration</li>
                    <li>Keyboard interrupt (IRQ 1)</li>
                    <li>Mouse interrupt (IRQ 12)</li>
                    <li>Audio interrupt (IRQ 5)</li>
                </ul>

                <h3>‚úÖ Exception Handling</h3>
                <ul class="feature-list">
                    <li>Page fault handler with CR2 address reading</li>
                    <li>General protection fault handling</li>
                    <li>Division by zero exception</li>
                    <li>Invalid opcode exception</li>
                    <li>Stack fault handling</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üñ•Ô∏è Hardware Drivers</h2>
                <h3>‚úÖ Input Devices</h3>
                <ul class="feature-list">
                    <li>PS/2 Keyboard driver with circular buffer</li>
                    <li>PS/2 Mouse driver with 3/5 button + scroll wheel support</li>
                    <li>Mouse type detection (standard/wheel/5-button)</li>
                    <li>Configurable sample rates and resolution</li>
                </ul>

                <h3>‚úÖ Storage Devices</h3>
                <ul class="feature-list">
                    <li>ATA/IDE hard disk driver</li>
                    <li>CD-ROM support</li>
                    <li>Basic disk I/O operations</li>
                    <li>Sector-based read/write</li>
                </ul>

                <h3>‚úÖ Audio System</h3>
                <ul class="feature-list">
                    <li>Sound Blaster 16 driver</li>
                    <li>8-bit/16-bit audio support</li>
                    <li>Mono/Stereo playback</li>
                    <li>DMA-based audio transfer (channels 1 and 5)</li>
                    <li>Volume control (master and PCM)</li>
                    <li>Sample rate configuration</li>
                    <li>Audio format detection</li>
                </ul>

                <h3>‚úÖ Video System</h3>
                <ul class="feature-list">
                    <li>VGA text mode (80x25)</li>
                    <li>VBE (VESA BIOS Extensions) graphics support</li>
                    <li>Framebuffer access</li>
                    <li>Basic graphics primitives</li>
                </ul>

                <h3>‚úÖ Serial Communication</h3>
                <ul class="feature-list">
                    <li>COM1/COM2 serial port drivers</li>
                    <li>Debug output via serial</li>
                    <li>Configurable baud rates</li>
                    <li>Serial interrupt handling</li>
                </ul>

                <h3>‚úÖ Timer Systems</h3>
                <ul class="feature-list">
                    <li>PIT (Programmable Interval Timer)</li>
                    <li>RTC (Real Time Clock)</li>
                    <li>HPET (High Precision Event Timer)</li>
                    <li>LAPIC (Local APIC Timer)</li>
                    <li>Unified clock system abstraction</li>
                    <li>Timer cascade with best available timer selection</li>
                </ul>

                <h3>‚úÖ DMA Controller</h3>
                <ul class="feature-list">
                    <li>8-channel DMA support (0-7)</li>
                    <li>8-bit and 16-bit transfer modes</li>
                    <li>Audio DMA integration</li>
                    <li>Channel enable/disable control</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üìÅ File System</h2>
                <h3>‚úÖ Virtual File System (VFS)</h3>
                <ul class="feature-list">
                    <li>Unified filesystem abstraction layer</li>
                    <li>Multiple filesystem support framework</li>
                    <li>Standard file operations (open, read, write, close)</li>
                    <li>Directory operations (mkdir, rmdir, ls)</li>
                    <li>File metadata handling</li>
                </ul>

                <h3>‚úÖ MINIX Filesystem</h3>
                <ul class="feature-list">
                    <li>Complete MINIX filesystem implementation</li>
                    <li>Inode-based file storage</li>
                    <li>Directory structure support</li>
                    <li>File creation, deletion, and modification</li>
                    <li>Integrated with VFS layer</li>
                </ul>

                <h3>‚úÖ File Operations</h3>
                <ul class="feature-list">
                    <li>File creation (touch)</li>
                    <li>File deletion (rm)</li>
                    <li>Directory creation (mkdir)</li>
                    <li>Directory removal (rmdir)</li>
                    <li>File content display (cat)</li>
                    <li>Directory listing (ls)</li>
                    <li>File writing capabilities</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üë§ User Space</h2>
                <h3>‚úÖ C Library (LibC)</h3>
                <ul class="feature-list">
                    <li>Freestanding C library implementation</li>
                    <li>Standard headers: stdio.h, stdlib.h, unistd.h, stdint.h, stddef.h</li>
                    <li>I/O functions: printf(), puts(), putchar()</li>
                    <li>Memory functions: malloc(), free()</li>
                    <li>Process functions: exit(), getpid()</li>
                    <li>System call wrappers</li>
                </ul>

                <h3>‚úÖ Printf Implementation</h3>
                <ul class="feature-list">
                    <li>Format specifiers: %d (integers), %s (strings), %c (characters)</li>
                    <li>Variable argument support</li>
                    <li>Output to stdout</li>
                </ul>

                <h3>‚úÖ User Programs</h3>
                <ul class="feature-list">
                    <li>Echo command implementation</li>
                    <li>Shell integration for user programs</li>
                    <li>ELF loader (basic implementation)</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üêö Shell System</h2>
                <h3>‚úÖ Interactive Shell</h3>
                <ul class="feature-list">
                    <li>Command-line interface in Ring 3 (user mode)</li>
                    <li>Built-in commands: ls, ps, cat, mkdir, rmdir, touch, rm, fork, clear, help, exit, malloc, sbrk, exec</li>
                </ul>

                <h3>‚úÖ Shell Features</h3>
                <ul class="feature-list">
                    <li>Command parsing and execution</li>
                    <li>Process management integration</li>
                    <li>Filesystem operation support</li>
                    <li>Memory management testing</li>
                    <li>Error handling and feedback</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üåê Network System</h2>
                <h3>üîÑ Basic TCP/IP Stack (In Development)</h3>
                <ul class="feature-list">
                    <li>Basic implementation using lightweight IoT library</li>
                    <li>Fundamental TCP/IP support for connectivity</li>
                    <li>Simplified socket interface</li>
                    <li>Basic Ethernet driver framework</li>
                    <li>Ping utility planned</li>
                    <li>Minimalist approach to reduce complexity</li>
                </ul>
                <p><small><strong>Note:</strong> Opted for a basic implementation with IoT library instead of porting Linux's complete stack (1.5M lines) to keep the kernel lightweight and manageable.</small></p>
            </div>

            <div class="info-card">
                <h2>üîß Build System</h2>
                <h3>‚úÖ Multi-Target Build</h3>
                <ul class="feature-list">
                    <li>Desktop target (full features, 256MB heap, 1024 processes)</li>
                    <li>Server target (optimized networking, 1GB heap, 4096 processes)</li>
                    <li>IoT target (power management, 16MB heap, 64 processes)</li>
                    <li>Embedded target (minimal features, 4MB heap, 16 processes)</li>
                </ul>

                <h3>‚úÖ Multi-Architecture</h3>
                <ul class="feature-list">
                    <li>x86-64 production support</li>
                    <li>x86-32 experimental support</li>
                    <li>ARM development framework</li>
                    <li>Architecture abstraction layer (HAL)</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>‚ö†Ô∏è Current Limitations</h2>
                <h3>‚ùå Not Yet Implemented</h3>
                <ul class="feature-list">
                    <li>SMP (Symmetric Multiprocessing) support</li>
                    <li>Dynamic kernel modules</li>
                    <li>Advanced IPC (pipes, message queues)</li>
                    <li>Network stack (TCP/IP)</li>
                    <li>USB support</li>
                    <li>Advanced GUI/Window manager</li>
                    <li>Signal handling</li>
                    <li>Copy-on-write memory</li>
                    <li>Swap memory support</li>
                    <li>Advanced filesystem features (ext2/3/4)</li>
                </ul>

                <h3>‚ö†Ô∏è Known Issues</h3>
                <ul class="feature-list">
                    <li>Fork() context switching needs refinement</li>
                    <li>Limited ELF loader functionality</li>
                    <li>No zombie process reaping in init</li>
                    <li>Basic memory allocator (advanced versions in development)</li>
                    <li>Single CPU support only</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üìä Technical Specifications</h2>
                <h3>Memory Layout</h3>
                <div class="code-block">
                    <pre>Kernel Space: 0x100000 - 0x800000 (1MB-8MB)
Heap Space:   0x800000 - 0x2000000 (8MB-32MB, 24MB total)
User Space:   0x40000000+ (1GB+)</pre>
                </div>

                <h3>Performance Metrics</h3>
                <ul class="feature-list">
                    <li>Context switch time: ~microseconds (assembly optimized)</li>
                    <li>Scheduler complexity: O(log n) with Red-Black Tree</li>
                    <li>Memory allocation: O(1) for simple allocator</li>
                    <li>Interrupt latency: Minimal with optimized ISRs</li>
                </ul>

                <h3>Resource Limits (Desktop Target)</h3>
                <ul class="feature-list">
                    <li>Maximum processes: 1024</li>
                    <li>Maximum threads: 4096</li>
                    <li>Heap size: 256MB</li>
                    <li>Scheduler quantum: 10ms</li>
                    <li>I/O buffer size: 64KB</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>üéØ Roadmap</h2>
                <h3>Short Term (Next Release)</h3>
                <ul class="feature-list">
                    <li>Fix fork() context switching issues</li>
                    <li>Implement proper zombie reaping</li>
                    <li>Integrate basic TCP/IP stack with IoT library</li>
                    <li>Improve ELF loader</li>
                    <li>Add USB framework</li>
                </ul>

                <h3>Medium Term</h3>
                <ul class="feature-list">
                    <li>SMP support</li>
                    <li>Advanced GUI system</li>
                    <li>Basic networking expansion (more protocols, optimizations)</li>
                    <li>Dynamic kernel modules</li>
                    <li>Advanced IPC mechanisms</li>
                </ul>

                <h3>Long Term</h3>
                <ul class="feature-list">
                    <li>Native application support (Doom, GCC, Bash)</li>
                    <li>Complete POSIX compatibility</li>
                    <li>Advanced filesystem support</li>
                    <li>Hardware abstraction improvements</li>
                    <li>Performance optimizations</li>
                </ul>
            </div>
        </section>

        <section id="development" class="section">
            <h1 class="titulo-guia">Development Guide</h1>

            <div class="info-card">
                <p>
                <div class="code-block">
                    <strong>-</strong> This section is in case someone is interested in contributing to the project. <strong>They are not
                        strict rules, they are simply recommendations
                        to make it more bearable.</strong>
                </div>
                </p>
                <h2>What do you need to know to contribute?</h2>
                More than anything the following:
                <li>Know structured/functional/object-oriented programming as necessary for the language.
                </li>
                <li>Know C or C++ or Rust.</li>
                <li>Assembly if you contribute to subsystems very close to the hardware, but I recommend knowing the basics to know how <i>panic(), boot.asm, etc.</i> work</li>
                <li><strong>Know how a makefile works</strong>, how to compile subsystems by parts, why
                    subsystems have to be compiled separately with their own makefile</li>
                <li><strong>General development tools</strong>: GIT/GitHub, how to create, change, pull and launch PR's between branches</li>
                <li><strong>Basic QEMU.</strong> How the VM works, how the generated image is loaded when compiling the kernel.</li>
                <li><strong>Knowing Bash is a plus for quick testing</strong>, since you can start QEMU with a script without repeating the complete command.</li>
                <li>Communication. <strong>Argue decisions about PR's</strong>, debate healthily about it.
                </li>
                <li>Know how to use AI's in general to optimize debugging and adapt it to code conventions.
                </li>
                <li>Know that, when contributing, <strong>you can be maintainer of the subsystem you contributed to</strong>. And if
                    you can't provide maintenance recurrent to the subsystem, <strong>leave it well documented</strong>.</li>
                <br>
                    Similarly, <strong>you don't have to be an expert to contribute to the kernel. Simply with having the desire
                    to learn/study about what you're going to contribute is more than enough</strong>.

                <h2>Environment Setup</h2>
                <h3>Required Dependencies:</h3>
                <li>Basically have installed: the C/Cpp compiler (gcc/g++), the asm compiler (nasm), make
                    for compilation and
                    QEMU as test vm.
                </li>
                I would give you the commands or websites to install, but chatgpt can solve it better for you.
                <br><br>

                <div class="code-block">
                    <strong>NOTE</strong>: Since this project is a kernel, it's <i>Freestanding</i>. That means you
                    <strong>can't include libraries like
                        stdio.h to do a <code>print(), write()</code>, etc. because there's no operating system that
                        responds to those functions </strong>. <strong>You are the
                        operating system</strong>. that's why, in the repo I have the folder of dependencies "includes".
                    </strong>
                </div>

            </div>
            <div class="info-card">
                <h2>How do I write code?</h2>
                <h3>Naming Conventions:</h3>
                <ul class="feature-list">
                    <li>Functions: <code>snake_case()</code></li>
                    <li>Macros: <code>UPPER_CASE</code></li>
                    <li>Structs: <code>struct_name_t</code></li>
                    <li>Global variables: <code>g_variable_name</code></li>
                    <li>Constants: <code>CONSTANT_NAME</code></li>
                    <li>includes: <code>#INCLUDE -ir0/Lib.h - </code>(are being migrated to that format)</li>
                </ul>
                <h3>Comments:</h3>
                <ul class="feature-list">
                    <li>header files .h of documented functions</li>
                    <li>Source code files with comments in some functions, but more limited</li>
                    <li>Explanation of complex algorithms</li>
                    <li>TO DO's clearly marked</li>
                    <li>References to technical documentation</li>
                </ul>
                <small>This is approximate. I generally try to respect those conventions as much as I can.</small>
                <br><br>
                <li>Something like this would be in this example an average source code file:</li>
                <br>
                <img src="/Assets/funcion.c.png" alt="" srcset="" style="width: 50%;">
                <br>
                <i>Notice how I use the braces below the function name and the same in conditionals,
                    loops, etc. Also how I don't use them directly when the conditional has a single line
                    or there's certain nesting.</i>
                <br>
                <br>
                <li>This is how I handle headers (or most):</li>
                <br><br>
                <img src="/Assets/header.png" alt="" srcset="">
                <br>
                <i>Large comments usually go in these .h and in the source we make notes.</i>
            </div>

            <div class="info-card">
                <h2>How to compile (for now)</h2>
                <div class="code-block">
                    <li>There must be a makefile in all subsystems, so it should be possible to do <i>make
                            "subsystem"</i></li> <br>
                    <li>Then, the kernel has a general makefile to generate the binary, with its respective clean.
                        For now it's used like this: <i>make all</i></li> <br>
                    <li>In the future, there will surely be compilation strategies that allow compiling the entire kernel
                        for its different uses.</li>
                </div>
            </div>
        </section>

        <section id="panic" class="section">
            <h1 class="titulo-guia">Kernel Subsystems</h1>
            <div class="code-block">
                <p>
                    <strong>-</strong> This section details the main subsystems that compose the IR0 kernel,
                    their current development status and technical characteristics of each one.
                    <br>
                    <br>
                    The best way to understand the internal operation is by reviewing the source code in the
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank"
                        rel="noopener noreferrer" class="link-repo">GitHub Repository</a>.
                </p>
            </div>

            <div class="info-card">
                <h2>üîÑ Scheduler</h2>
                <p>
                    The scheduler is the heart of the multiprocessing system. Currently implements a simple
                    <a href="https://en.wikipedia.org/wiki/Round-robin_scheduling" target="_blank"
                        rel="noopener noreferrer">Round-Robin</a> algorithm as fallback, but the goal is to migrate to a
                    preemptive scheduler with priority scheme similar to Linux's CFS (Completely Fair Scheduler).
                </p>
                <h3>Current Features:</h3>
                <ul class="feature-list">
                    <li>Round-Robin algorithm with fixed quantum</li>
                    <li>Support for multiple priority levels</li>
                    <li>Basic process state management (Ready, Running, Blocked)</li>
                    <li>Optimized context switching in assembly</li>
                </ul>
                <h3>Upcoming Improvements:</h3>
                <ul class="feature-list">
                    <li>Preemptive scheduler implementation</li>
                    <li>CFS algorithm for fair CPU distribution</li>
                    <li>Real-time scheduling support</li>
                    <li>Load balancing between cores</li>
                </ul>
                <p><strong>Files:</strong> scheduler/scheduler.c, scheduler/task.h, scheduler/switch/switch.asm</p>
            </div>

            <div class="info-card">
                <h2>üíæ Filesystem</h2>
                <p>
                    Own filesystem based on <a href="https://es.wikipedia.org/wiki/Ext2" target="_blank"
                        rel="noopener noreferrer">EXT2</a> but with modern innovations. The distinctive feature
                    is the integration of a vectorial database to optimize file search and indexing operations.
                </p>
                <h3>Technical Features:</h3>
                <ul class="feature-list">
                    <li>Hierarchical directory structure</li>
                    <li>Support for files up to 2TB</li>
                    <li>Journaling for failure recovery</li>
                    <li>Transparent file compression</li>
                    <li>Vectorial indexing for fast searches</li>
                </ul>
                <h3>Innovations:</h3>
                <ul class="feature-list">
                    <li>Integration with <a href="https://github.com/victor-base/libvictor" target="_blank" rel="noopener noreferrer">libvictor</a> for semantic searches</li>
                    <li>Intelligent cache based on access patterns</li>
                    <li>Extended metadata support</li>
                    <li>File-level encryption</li>
                </ul>
                <p><strong>Status:</strong> Active development</p>
                <p><strong>Files:</strong> fs/ext2.c, fs/victor_index.c, fs/journal.c</p>
            </div>

            <div class="info-card">
                <h2>‚ö° Interrupt System</h2>
                <p>
                    Robust interrupt and exception handling system that ensures kernel stability
                    and provides a clean interface for handling hardware and software events.
                </p>
                <h3>Main Components:</h3>
                <ul class="feature-list">
                    <li><strong>IDT (Interrupt Descriptor Table):</strong> 256-entry table for interrupt mapping</li>
                    <li><strong>ISR (Interrupt Service Routines):</strong> Optimized handlers in assembly</li>
                    <li><strong>Exception Handler:</strong> Processor exception handling</li>
                    <li><strong>IRQ Manager:</strong> Hardware interrupt management</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Complete page fault handling with automatic recovery</li>
                    <li>Nested interrupts with priorities</li>
                    <li>Deferred interrupt processing</li>
                    <li>Interrupt coalescing for optimization</li>
                </ul>
                <p><strong>Files:</strong> interrupt/idt.c, interrupt/interrupt.asm, interrupt/isr_handlers.c, interrupt/irq.c</p>
            </div>

            <div class="info-card">
                <h2>üöÄ Boot Subsystem</h2>
                <p>
                    Initialization system that prepares the environment for kernel execution, handling the
                    transition from bootloader to user space.
                </p>
                <h3>Boot Phases:</h3>
                <ul class="feature-list">
                    <li><strong>Phase 1:</strong> Processor initialization and protected mode</li>
                    <li><strong>Phase 2:</strong> Paging and virtual memory configuration</li>
                    <li><strong>Phase 3:</strong> Critical subsystems initialization</li>
                    <li><strong>Phase 4:</strong> First process loading (init)</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Support for multiple architectures (x86-64, ARM64)</li>
                    <li>Independent bootloader with UEFI support</li>
                    <li>Automatic recovery from boot failures</li>
                    <li>Integrated recovery mode</li>
                </ul>
                <img src="/Assets/diag.png" alt="Boot diagram" srcset="" style="width: 100%;">
                <p><strong>Files:</strong> boot/boot.asm, boot/kmain.c, boot/arch.c, boot/kernel_start.c</p>
            </div>

            <div class="info-card">
                <h2>üõ°Ô∏è Memory Management</h2>
                <p>
                    Advanced memory management system that provides process isolation, performance optimization
                    and protection against unauthorized access.
                </p>
                <h3>Components:</h3>
                <ul class="feature-list">
                    <li><strong>Memory Manager:</strong> Physical and virtual page management</li>
                    <li><strong>Page Allocator:</strong> Efficient memory allocation</li>
                    <li><strong>Slab Allocator:</strong> Optimization for small objects</li>
                    <li><strong>Memory Protection:</strong> Access control and permissions</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>4-level paging (48-bit addressing)</li>
                    <li>Transparent memory compression</li>
                    <li>NUMA awareness for multi-socket systems</li>
                    <li>Memory deduplication</li>
                </ul>
                <p><strong>Files:</strong> mm/page_alloc.c, mm/slab.c, mm/vmalloc.c, mm/protection.c</p>
            </div>

            <div class="info-card">
                <h2>üåê Network Subsystem</h2>
                <p>
                    Complete network stack based on Linux but optimized for the IR0 kernel, providing
                    support for modern protocols and specific optimizations.
                </p>
                <h3>Supported Protocols:</h3>
                <ul class="feature-list">
                    <li>Complete TCP/IP stack</li>
                    <li>UDP with latency optimizations</li>
                    <li>HTTP/2 and HTTP/3</li>
                    <li>QUIC for fast connections</li>
                    <li>IPv6 with automatic transition</li>
                </ul>
                <h3>Optimizations:</h3>
                <ul class="feature-list">
                    <li>Zero-copy networking</li>
                    <li>Kernel bypass for high-performance applications</li>
                    <li>Network function virtualization (NFV)</li>
                    <li>Intelligent load balancing</li>
                </ul>
                <p><strong>Status:</strong> Integration with Linux networking stack</p>
                <p><strong>Files:</strong> net/tcp.c, net/udp.c, net/socket.c, net/protocols/</p>
            </div>

            <div class="info-card">
                <h2>üîß Driver Subsystem</h2>
                <p>
                    Modular framework for hardware driver development and management, with support for
                    hot-plugging and automatic device management.
                </p>
                <h3>Driver Types:</h3>
                <ul class="feature-list">
                    <li><strong>Block Devices:</strong> Disks, SSDs, storage devices</li>
                    <li><strong>Character Devices:</strong> Terminals, input devices</li>
                    <li><strong>Network Devices:</strong> Network cards, WiFi, Bluetooth</li>
                    <li><strong>Graphics:</strong> GPUs, framebuffers, hardware acceleration</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Unified driver framework</li>
                    <li>Hardware auto-detection</li>
                    <li>Integrated power management</li>
                    <li>Driver signing and verification</li>
                </ul>
                <p><strong>Files:</strong> drivers/core.c, drivers/block/, drivers/char/, drivers/net/</p>
            </div>

            <div class="info-card">
                <h2>üîê Security System</h2>
                <p>
                    Comprehensive security framework that protects the kernel and user processes, implementing
                    multiple layers of protection and security auditing.
                </p>
                <h3>Security Components:</h3>
                <ul class="feature-list">
                    <li><strong>Access Control:</strong> Role-based access control (RBAC)</li>
                    <li><strong>Capability System:</strong> Granular capability system</li>
                    <li><strong>Seccomp:</strong> Syscall filtering for sandboxing</li>
                    <li><strong>LSM (Linux Security Modules):</strong> Interchangeable security modules</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>ASLR (Address Space Layout Randomization)</li>
                    <li>Stack canaries and buffer overflow protection</li>
                    <li>Automatic kernel hardening</li>
                    <li>Security event auditing</li>
                    <li>TPM integration for integrity measurement</li>
                </ul>
                <p><strong>Files:</strong> security/capability.c, security/seccomp.c, security/lsm/, security/audit.c</p>
            </div>

            <div class="info-card">
                <h2>‚ö° Power Management</h2>
                <p>
                    Advanced power management system that optimizes battery consumption in mobile devices
                    and reduces energy consumption in servers while maintaining performance.
                </p>
                <h3>Power States:</h3>
                <ul class="feature-list">
                    <li><strong>Suspend to RAM:</strong> Fast suspension with instant recovery</li>
                    <li><strong>Suspend to Disk:</strong> Complete hibernation</li>
                    <li><strong>Standby:</strong> Low-power standby mode</li>
                    <li><strong>Dynamic Frequency Scaling:</strong> Dynamic CPU frequency adjustment</li>
                </ul>
                <h3>Optimizations:</h3>
                <ul class="feature-list">
                    <li>Intelligent CPU idle management</li>
                    <li>Wake-on-LAN and wake-on-timer</li>
                    <li>Power capping for servers</li>
                    <li>Automatic thermal management</li>
                    <li>Battery health monitoring</li>
                </ul>
                <p><strong>Files:</strong> power/suspend.c, power/cpuidle.c, power/thermal.c, power/battery.c</p>
            </div>

            <div class="info-card">
                <h2>üéØ Virtualization</h2>
                <p>
                    Virtualization subsystem that allows running multiple operating systems simultaneously,
                    with support for containers and complete virtual machines.
                </p>
                <h3>Virtualization Types:</h3>
                <ul class="feature-list">
                    <li><strong>Containers:</strong> Light isolation with namespaces and cgroups</li>
                    <li><strong>KVM:</strong> Kernel-based Virtual Machine for complete VMs</li>
                    <li><strong>Xen:</strong> Type 1 hypervisor for bare-metal virtualization</li>
                    <li><strong>Docker/OCI:</strong> Support for container standards</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Hardware-assisted virtualization (Intel VT-x, AMD-V)</li>
                    <li>Nested virtualization</li>
                    <li>Live VM migration</li>
                    <li>GPU passthrough for graphics acceleration</li>
                    <li>Memory ballooning and overcommit</li>
                </ul>
                <p><strong>Files:</strong> virt/kvm/, virt/xen/, kernel/nsproxy.c, kernel/cgroup.c</p>
            </div>

            <div class="info-card">
                <h2>üìä Monitoring and Debugging</h2>
                <p>
                    Complete monitoring and debugging system that provides deep visibility into kernel operation
                    and enables real-time problem diagnosis.
                </p>
                <h3>Debugging Tools:</h3>
                <ul class="feature-list">
                    <li><strong>Kprobes:</strong> Dynamic insertion points in the kernel</li>
                    <li><strong>ftrace:</strong> Function and event tracer</li>
                    <li><strong>perf:</strong> Advanced performance profiler</li>
                    <li><strong>eBPF:</strong> Dynamic kernel programming</li>
                </ul>
                <h3>Metrics and Monitoring:</h3>
                <ul class="feature-list">
                    <li>CPU, memory and I/O profiling</li>
                    <li>Network packet tracing</li>
                    <li>System call monitoring</li>
                    <li>Kernel panic analysis</li>
                    <li>Performance counters</li>
                </ul>
                <p><strong>Files:</strong> kernel/trace/, kernel/debug/, kernel/profiling/, kernel/bpf/</p>
            </div>

            <div class="info-card">
                <h2>üîß Device Tree</h2>
                <p>
                    Hardware description system that allows the kernel to automatically discover and configure
                    hardware devices without needing hardcoded specific drivers.
                </p>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Declarative hardware description</li>
                    <li>Support for multiple architectures</li>
                    <li>Dynamic overlays for configuration</li>
                    <li>UEFI/ACPI firmware compatibility</li>
                </ul>
                <h3>Benefits:</h3>
                <ul class="feature-list">
                    <li>Faster boot on embedded systems</li>
                    <li>Automatic device configuration</li>
                    <li>Cross-platform portability</li>
                    <li>Reduction of platform-specific code</li>
                </ul>
                <p><strong>Files:</strong> drivers/of/, drivers/acpi/, drivers/firmware/</p>
            </div>

            <div class="info-card">
                <h2>üéÆ Graphics and Multimedia</h2>
                <p>
                    Graphics subsystem that provides hardware acceleration, multi-monitor support
                    and advanced multimedia capabilities.
                </p>
                <h3>Graphics Components:</h3>
                <ul class="feature-list">
                    <li><strong>DRM (Direct Rendering Manager):</strong> Modern graphics management</li>
                    <li><strong>KMS (Kernel Mode Setting):</strong> Display mode configuration</li>
                    <li><strong>GEM (Graphics Execution Manager):</strong> Graphics memory management</li>
                    <li><strong>V4L2:</strong> Video4Linux for video capture</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Support for modern GPUs (NVIDIA, AMD, Intel)</li>
                    <li>Hardware video acceleration</li>
                    <li>Multi-head display</li>
                    <li>HDR and color management</li>
                    <li>VR/AR support</li>
                </ul>
                <p><strong>Files:</strong> drivers/gpu/drm/, drivers/media/, drivers/video/</p>
            </div>

            <div class="info-card">
                <h2>üîä Audio Subsystem</h2>
                <p>
                    Advanced audio system that provides support for multiple formats, real-time audio processing
                    and management of complex audio devices.
                </p>
                <h3>Audio Components:</h3>
                <ul class="feature-list">
                    <li><strong>ALSA (Advanced Linux Sound Architecture):</strong> Main audio framework</li>
                    <li><strong>PulseAudio:</strong> Sound server for users</li>
                    <li><strong>JACK:</strong> Low-latency professional audio</li>
                    <li><strong>ASoC (ALSA System on Chip):</strong> Audio for embedded systems</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>HD format support (24-bit, 192kHz)</li>
                    <li>7.1 surround audio</li>
                    <li>Noise cancellation</li>
                    <li>Bluetooth audio (A2DP, aptX)</li>
                    <li>MIDI and audio synthesis</li>
                </ul>
                <p><strong>Files:</strong> sound/core/, sound/soc/, sound/pci/, sound/usb/</p>
            </div>

            <div class="info-card">
                <h2>üì± Input/Output Subsystem</h2>
                <p>
                    Unified input and output system that handles all user interface devices,
                    from keyboards and mice to touchscreens and sensors.
                </p>
                <h3>Device Types:</h3>
                <ul class="feature-list">
                    <li><strong>HID (Human Interface Devices):</strong> Keyboards, mice, gamepads</li>
                    <li><strong>Touchscreens:</strong> Capacitive and resistive touchscreens</li>
                    <li><strong>Sensors:</strong> Accelerometers, gyroscopes, magnetometers</li>
                    <li><strong>Haptic Feedback:</strong> Vibration and tactile feedback</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Multi-touch support</li>
                    <li>Gesture recognition</li>
                    <li>Accessibility features</li>
                    <li>Automatic hot-plugging</li>
                    <li>Device power management</li>
                </ul>
                <p><strong>Files:</strong> drivers/input/, drivers/hid/, drivers/iio/</p>
            </div>

        </section>

        <section id="descarga" class="section">
            <h1 class="titulo-guia">Downloads</h1>

            <div class="info-card">
                <p>
                    <li>The kernel binary download will be available in this section when the first stable version of the mainline branch is released.</li>
                </p>
                
            
            </div>
        </section>
    </div>

</body>

</html>
