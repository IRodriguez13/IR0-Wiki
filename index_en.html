<!DOCTYPE html>
<html lang="en">
<!-- If you're reading this, first I already told you that I'm not using any trendy hipster framework like React, next, nest, whatever. At most Blazor. -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/Assets/cuatro-nucleos.png" type="image/x-icon">
    <title>IR0 Kernel - Wiki</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <script src="main.js"></script>

    <nav class="navbar">
        <div class="nav-container">
            <div class="logo"><a href="index_en.html" target="_blank" rel="noopener noreferrer"
                    style="text-decoration: none; color: white;">IR0 Wiki</a></div>
            <ul class="nav-menu">
                <li><a href="#overview" class="nav-link active" onclick="showSection('overview')">Home</a></li>
                <li><a href="#architecture" class="nav-link" onclick="showSection('architecture')">Architecture</a></li>
                <li><a href="#branches" class="nav-link" onclick="showSection('branches')">Branches</a></li>
                <li><a href="#development" class="nav-link" onclick="showSection('development')">Development</a></li>
                <li><a href="#panic" class="nav-link" onclick="showSection('panic')">Subsystems</a></li>
                <li><a href="#overview" class="nav-link" onclick="showSection('descarga')">Download</a></li>
                <li class="language-dropdown">
                    <button class="translate-btn" onclick="toggleLanguageMenu()">üåê EN</button>
                    <div class="language-menu" id="languageMenu">
                        <a href="index.html" class="language-option">üá™üá∏ Espa√±ol</a>
                        <a href="index_en.html" class="language-option active">üá∫üá∏ English</a>
                    </div>
                </li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <section id="overview" class="section active">
            <h1 class="titulo-principal">IR0 Kernel - Overview</h1>

            <div class="info-card">
                <p>
                    The purpose of this "wiki", web documentation, guide, however you call it, is to use it as a personal memory aid
                    for kernel development.
                    It doesn't have to be an ultra-aesthetic page, but I'm trying hard so it doesn't show that I made it
                    with vanilla html, css and js like some amateur project
                    that's out there. <br> <br>
                    A minimally functional operating system kernel (all the <a
                        href="https://en.wikipedia.org/wiki/User_space_and_kernel_space" target="_blank"
                        rel="noopener noreferrer">Kernel Space</a> plus a minimal user space)
                    can easily run in <strong>15,000</strong> lines of code, so as you'll see;
                    it's humanly impossible to memorize and understand the entire kernel flow by myself. Besides, there are many complex subsystems working together at a low level to mediate between hardware and software.
                </p>
            </div>

            <div class="info-card">
                <h2>What is IR0?</h2>
                <p>
                    <strong>IR0</strong> is a <strong>multipurpose operating system kernel</strong> developed
                    from scratch for <strong>x86-64</strong> architecture written primarily in <strong>C</strong> and <strong>ASM</strong> (Although
                    I have no problem including code from other specialized languages in performance such as
                    <strong>Cpp</strong> or <strong>Rust</strong>).
                    <br>
                    I'm creating it to learn more about operating systems and be able to use it as raw material
                    for another project that replicates <a href="https://learn.microsoft.com/es-es/windows/wsl/about"
                        target="_blank" rel="noopener noreferrer">WSL2</a> but with my own kernel.
                    I don't rule out scaling it enough to make it usable in minimal servers or even IoT,
                    but I understand that's in the very long term.
                    <br>
                    <br>
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank" rel="noopener noreferrer">This
                        is its GitHub Repository.</a>
                </p>
            </div>

            <div class="info-card">
                <h2>Main Features and Future Ones</h2>
                <ul class="feature-list">
                    <li>Monolithic kernel for x86-64 architecture</li>
                    <li>Memory management with paging in those two architectures</li>
                    <li>Interrupt and exception handling</li>
                    <li>Custom bootloader (Only in x86 and I'll probably migrate all architectures to GRUB)</li>
                    <li>The assembly code I use is in syntax of <a
                            href="https://cs.lmu.edu/~ray/notes/nasmtutorial/" target="_blank"
                            rel="noopener noreferrer">Intel Netwide Assembler (nasm)</a>.</li>
                    <li>Own filesystem based on EXT with vectorial database optimization in user space</li>
                    <li>Network stack and <a href="https://opensource.com/article/22/12/linux-abi" target="_blank"
                            rel="noopener noreferrer">ABI</a> borrowed from Linux (They are millions of lines of code that
                        I don't plan to write alone)</li>
                    <li>Own syscalls and some mapped from Linux</li>
                    <li>Some drivers for minimal hardware handling.</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>Project Status</h2>
                <p><strong>Version:</strong> not yet versioned (but let's say pre-release for now.)<br>
                    <strong>Architecture:</strong> x86-64 (i386)<br>
                    <strong>Bootloader:</strong> GRUB<br>
                    <strong>ASM Syntax:</strong> Intel
                </p>
            </div>
        </section>

        <section id="architecture" class="section">
            <h1 class="titulo-principal">System Architecture</h1>

            <div class="architecture-box">
                <img src="Assets/scheme-core.png" alt="ir0-arch" srcset="">
            </div>
            <div class="info-card">
                <h2>Architecture and "Philosophy" of the project</h2>
                <p>
                    Unlike kernels such as <a href="https://en.wikipedia.org/wiki/Windows_NT" target="_blank"
                        rel="noopener noreferrer">Microsoft's NT kernel (Hybrid)</a>, <a
                        href="https://www.redox-os.org/" target="_blank" rel="noopener noreferrer">Redox-OS
                        (Microkernel)</a>,
                    or the same <a href="https://es.wikipedia.org/wiki/MINIX" target="_blank"
                        rel="noopener noreferrer">MINIX kernel (microkernel)</a>, IR0 is based on a more similar architecture
                    to what Linux has, which is monolithic.
                    <br>

                    However, my main argument is that of performance. I understand that someone could come and
                    point out that, like any monolith, if a subcomponent breaks, the entire system crashes <small>(and
                        they would be right)</small>
                    but what I respond to that is <i>"What good does it do me that the kernel supports continuing without
                        filesystem if I can't do anything practical without it?"</i>, that is, it doesn't make sense that the
                    kernel
                    continues functioning <strong>without one of its key components running</strong>. <br><br>

                    That's why I don't see a better alternative (for now) than the <a
                        href="https://es.wikipedia.org/wiki/N%C3%BAcleo_monol%C3%ADtico" target="_blank"
                        rel="noopener noreferrer">monolithic</a> pattern. And it also saves me from having to interconnect
                    key subsystems with each other via IPC, which impacts performance of the Operating System. It's not
                    perfect, but it's stable. It's not entirely traceable and requires scaling little by little, but if it scales well it performs a lot. <br>

                    <br>
                    However, I also have disagreements with the <a
                        href="https://es.wikipedia.org/wiki/Filosof%C3%ADa_de_Unix" target="_blank"
                        rel="noopener noreferrer">UNIX philosophy</a>. They (among other things and very briefly)
                    consider
                    that if something fails, <i>let it fail well</i>. Which in kernel terms would be: <i>If the scheduler breaks, Panic() directly. If you have memory corruption (in kernel space),
                        Panic.</i><br>
                    And it's not that I question it for no reason, I simply ask (although without solutions yet) <i>"Why not rescue the system during Panic()?, or at least try"</i>. <br>
                    Beyond the philosophical point and to summarize, the kernel is monolithic because it's more performant and
                    I feel that the key pieces of the kernel must <strong>work without overhead</strong>. <br>
                    However, if in the future I needed to integrate some specific subsystem in a hybrid way,
                    I would surely be pragmatic.
                </p>
                <h2>Kernel Space is sacred</h2>
                <p>
                    I know I talk as if IR0 were used by thousands of people and all the history, but I'm going to give myself the luxury of opining
                    about it.
                    <br>So, the point is that kernel space <strong>has to be only habitable by subsystems
                        that work in that Environment</strong>,
                    nothing else. <br>
                    I understand that there are certain <a
                        href="https://www.reddit.com/r/riotgames/comments/1gxhfmh/the_future_of_riot_vanguard_and_kernel_level/"
                        target="_blank" rel="noopener noreferrer">manufacturers concerned about their clients' security</a> who,
                    coincidentally, have access to <i>every interruption that the user makes (they know what keys you press,
                        your session time every time you turn on the computer, etc.)</i> And all that because they have
                    software running in the <a href="https://en.wikipedia.org/wiki/User_space_and_kernel_space"
                        target="_blank" rel="noopener noreferrer">kernel space</a> with all the privileges that implies.
                    <br> <a href="https://en.wikipedia.org/wiki/Protection_ring" target="_blank"
                        rel="noopener noreferrer">RING 0</a> is only for the kernel. Everything that comes from RING 3
                    communicates with <i>syscalls()</i>, end of statement.
                </p>
                <h2>What do I borrow from Linux?</h2>
                <p>
                    If I intend to make IR0 work as support for servers (backends, games, etc), that can run docker and kubernetes (at least) and that, at some point,
                    can work as a base for IoT, I need to have first of all <strong>network support, with its drivers, support for modern network protocols</strong> plus <strong>all the algorithms that
                        they implement internally</strong>.
                    <br><br>
                    In the Linux Kernel there are more or less <i>1,500,000</i> lines of code <strong>ONLY THE COMPLETE NETWORK STACK</strong>.
                    <br>
                    Literally, if I wanted to build it from scratch, maybe it would take a decade and it wouldn't be ready. I don't feel so crazy really.
                    <br><br>
                    I'll show you what I need from the network stack:
                    <br><br>
                    <img src="/Assets/deepseek_mermaid_20250808_234e4e.png" alt="chiquita la pilita de red" srcset=""
                        style="width: 50%;">
                    <br>
                    <small><i>Understand hardware as the components of your <a
                                href="https://es.wikipedia.org/wiki/Placa_base" target="_blank"
                                rel="noopener noreferrer"></a>MOBO</i> that talk to the kernel.
                        Besides, here you can see clearly how the kernel mediates between hard and soft.</small>
                    <br><br>

                    We have the same issue with <strong>container support</strong>. Here the issue is a bit calmer because there are a couple less lines of code in total: <i>some 300,000 lines</i>
                    but still, as happens with the network stack, they are two completely separate projects.
                    <br> <br>
                    More or less this is what docker requires to work, from the app with its runtime, to its accesses in the kernel.
                    <br><br>
                    <img src="/Assets/docker.png" alt="" srcset="" style="width: 101%;">
                    <br>
                    <small>Notice that docker needs to start literally a virtual file system, besides limiting the cpu, access RAM, have a private network interface, uses namespaces to isolate its content from the environment, etc.
                    </small>
                    <br>
                <h2>How am I going to solve it?</h2>
                Well, if writing the network stack and container support is not trivial, integrating them outside their environment isn't either, but it's more human than diagramming, implementing and testing.
                <br><br>
                I'll most likely have to map the syscalls that that part of Linux expects in <a
                    href="https://es.wikipedia.org/wiki/Wine" target="_blank" rel="noopener noreferrer">Wine/Proton</a> style,
                or copy some of the ones they use natively if they serve me later.
                </p>

            </div>

            <div class="info-card">
                <h2>Directory Structure</h2>
                <p>
                    How the file structure can change constantly, I prefer you consult it in the
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank"
                        rel="noopener noreferrer">GitHub Repository</a>.
                </p>

            </div>

        </section>

        <section id="branches" class="section">
            <h1 class="titulo-principal">Branch Management</h1>
            <div class="info-card">
                <h2>Git Workflow</h2>
                <div class="code-block">
                    <article>Since it's the first time I write a project of this caliber, what I'm looking for
                        is that the Workflow for kernel development be
                        as clean, predictable and scalable as possible.
                        <br>
                        <br>
                        For that I use 3 main git branches in the
                        process: mainline, dev and feature (which although feature is not in the repository, it's the one used as convention for
                        integrating new code).
                        Where only <strong>mainline</strong> and <strong>dev</strong> are the only 2 <i>upstream
                            branches</i>.
                        <br>
                        <br>
                        <strong>experimental</strong> is a branch
                        divergent to <strong>dev</strong>, and <strong>feature</strong> is the branch that is created to send
                        contributions.
                    </article>
                </div>
            </div>

            <!-- mainline BRANCH -->
            <div class="branch-grid">
                <div class="branch-card">
                    <div class="branch-title">mainline</div>
                    <div class="status-badge status-stable">STABLE</div>
                    <p><strong>-</strong> Main branch with stable and tested code.</p>

                    <h3>Characteristics</h3>
                    <ul class="feature-list">
                        <li>Only tested and functional code</li>
                        <li>Complete documentation</li>
                        <li>My base for rc's.</li>
                        <li><strong>mainline is sacred</strong>, since this branch <strong>has to compile and boot always</strong>. It's the most stable of the two upstream branches.
                        </li>
                    </ul>

                </div>
                <!-- DEV BRANCH -->
                <div class="branch-card">
                    <div class="branch-title">dev</div>
                    <div class="status-badge status-development">STAGING</div>
                    <p><strong>-</strong> Active development branch where new features are implemented and tested.
                    </p>

                    <h3>Characteristics:</h3>
                    <ul class="feature-list">
                        <li>It's the mirror of <strong>mainline</strong>.</li>
                        <li>What gets merged here doesn't have to go to <strong>mainline</strong>.</li>
                        <li>New features in development that convinced me of feature</li>
                        <li>Code patches, refactors and optimizations</li>
                        <li>It can contain temporary bugs that are resolved one way or another in this branch.</li>
                    </ul>

                </div>

                <!-- feat BRANCH -->
                <div class="branch-card">
                    <div class="branch-title">feature</div>
                    <div class="status-badge status-feat">DEVELOPMENT</div>
                    <p><strong>-</strong>
                        I add it because it's the branch where feats are created that later go to upstream
                        merging to <strong>dev</strong>. It's the most unstable of all because it's where new code is integrated that must also be tested and reviewed before reaching merge.
                    </p>

                    <h3>Characteristics:</h3>
                    <ul class="feature-list">
                        <li>This is where I start to implement new functionalities or patches</li>
                        <li>It's the first one that gets debugged.</li>
                        <li>It's the one you would create when you fork the repo.</li>
                        <li>It's expected to compile before going to <strong>dev</strong>.</li>
                    </ul>
                </div>
                <!-- exp BRANCH -->

                <div class="branch-card">
                    <div class="branch-title">experimental</div>
                    <div class="status-badge status-exp">MISC</div>
                    <p><strong>-</strong>
                        In this branch, features are integrated unstable enough to end up in
                        <strong>mainline</strong>
                        but that may have potential in the future.
                    </p>

                    <h3>Characteristics:</h3>
                    <ul class="feature-list">
                        <li>It's a pure testing branch, it has nothing to do with stable upstream branches</li>
                        <li>Here fall the features and experiments that don't reach <strong>mainline</strong></li>
                        <li>Things that aren't tested in operating systems or new ideas</li>
                        <li>Stability is not so important in this branch</li>
                        <li>If they are tested enough without breaking anything, they may or may not merge to mainline first
                            passing through <strong>dev</strong> again.
                        </li>
                    </ul>
                </div>

            </div>

            <div class="info-card">
                <h2>How is merging from feature to mainline?</h2>

                <article>
                    Basically, you create your improvement/optimization <strong>from a fork of the repo with a new branch</strong> that will be something like <i>"feature/fix-scheduler"</i> for example. <br>
                    Then, <strong>you make PR to the upstream dev branch (not to mainline)</strong> and the review and merge is done if applicable. <br>
                    The merge to mainline depends on <strong>how aligned with the project I consider the feature is</strong>. <br>
                    Not even some of my own implementations would I merge directly to mainline for this same reason.
                </article>

            </div>

        </section>

        <section id="development" class="section">
            <h1 class="titulo-guia">Development Guide</h1>

            <div class="info-card">
                <p>
                <div class="code-block">
                    <strong>-</strong> This section is in case someone is interested in contributing to the project. <strong>They are not
                        strict rules, they are simply recommendations
                        to make it more bearable.</strong>
                </div>
                </p>
                <h2>What do you need to know to contribute?</h2>
                More than anything the following:
                <li>Know structured/functional/object-oriented programming as necessary for the language.
                </li>
                <li>Know C or C++ or Rust.</li>
                <li>Assembly if you contribute to subsystems very close to the hardware, but I recommend knowing the basics to know how <i>panic(), boot.asm, etc.</i> work</li>
                <li><strong>Know how a makefile works</strong>, how to compile subsystems by parts, why
                    subsystems have to be compiled separately with their own makefile</li>
                <li><strong>General development tools</strong>: GIT/GitHub, how to create, change, pull and launch PR's between branches</li>
                <li><strong>Basic QEMU.</strong> How the VM works, how the generated image is loaded when compiling the kernel.</li>
                <li><strong>Knowing Bash is a plus for quick testing</strong>, since you can start QEMU with a script without repeating the complete command.</li>
                <li>Communication. <strong>Argue decisions about PR's</strong>, debate healthily about it.
                </li>
                <li>Know how to use AI's in general to optimize debugging and adapt it to code conventions.
                </li>
                <li>Know that, when contributing, <strong>you can be maintainer of the subsystem you contributed to</strong>. And if
                    you can't provide maintenance recurrent to the subsystem, <strong>leave it well documented</strong>.</li>
                <br>
                    Similarly, <strong>you don't have to be an expert to contribute to the kernel. Simply with having the desire
                    to learn/study about what you're going to contribute is more than enough</strong>.

                <h2>Environment Setup</h2>
                <h3>Required Dependencies:</h3>
                <li>Basically have installed: the C/Cpp compiler (gcc/g++), the asm compiler (nasm), make
                    for compilation and
                    QEMU as test vm.
                </li>
                I would give you the commands or websites to install, but chatgpt can solve it better for you.
                <br><br>

                <div class="code-block">
                    <strong>NOTE</strong>: Since this project is a kernel, it's <i>Freestanding</i>. That means you
                    <strong>can't include libraries like
                        stdio.h to do a <code>print(), write()</code>, etc. because there's no operating system that
                        responds to those functions </strong>. <strong>You are the
                        operating system</strong>. that's why, in the repo I have the folder of dependencies "includes".
                    </strong>
                </div>

            </div>
            <div class="info-card">
                <h2>How do I write code?</h2>
                <h3>Naming Conventions:</h3>
                <ul class="feature-list">
                    <li>Functions: <code>snake_case()</code></li>
                    <li>Macros: <code>UPPER_CASE</code></li>
                    <li>Structs: <code>struct_name_t</code></li>
                    <li>Global variables: <code>g_variable_name</code></li>
                    <li>Constants: <code>CONSTANT_NAME</code></li>
                    <li>includes: <code>#INCLUDE -ir0/Lib.h - </code>(are being migrated to that format)</li>
                </ul>
                <h3>Comments:</h3>
                <ul class="feature-list">
                    <li>header files .h of documented functions</li>
                    <li>Source code files with comments in some functions, but more limited</li>
                    <li>Explanation of complex algorithms</li>
                    <li>TO DO's clearly marked</li>
                    <li>References to technical documentation</li>
                </ul>
                <small>This is approximate. I generally try to respect those conventions as much as I can.</small>
                <br><br>
                <li>Something like this would be in this example an average source code file:</li>
                <br>
                <img src="/Assets/funcion.c.png" alt="" srcset="" style="width: 50%;">
                <br>
                <i>Notice how I use the braces below the function name and the same in conditionals,
                    loops, etc. Also how I don't use them directly when the conditional has a single line
                    or there's certain nesting.</i>
                <br>
                <br>
                <li>This is how I handle headers (or most):</li>
                <br><br>
                <img src="/Assets/encabezado.png" alt="" srcset="">
                <br>
                <i>Large comments usually go in these .h and in the source we make notes.</i>
            </div>

            <div class="info-card">
                <h2>How to compile (for now)</h2>
                <div class="code-block">
                    <li>There must be a makefile in all subsystems, so it should be possible to do <i>make
                            "subsystem"</i></li> <br>
                    <li>Then, the kernel has a general makefile to generate the binary, with its respective clean.
                        For now it's used like this: <i>make all</i></li> <br>
                    <li>In the future, there will surely be compilation strategies that allow compiling the entire kernel
                        for its different uses.</li>
                </div>
            </div>
        </section>

        <section id="panic" class="section">
            <h1 class="titulo-guia">Kernel Subsystems</h1>
            <div class="code-block">
                <p>
                    <strong>-</strong> There's not much science here. I simply give a review of the subsystems and
                    some features to develop
                    in the future.
                    <br>
                    <br>

                    Still, the best way to internalize about kernel operation, is by looking at the code of the
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank"
                        rel="noopener noreferrer" class="link-repo">GitHub Repository</a>.
                </p>
            </div>

            <div class="info-card">
                <h2>Scheduler</h2>
                <p>
                    For now it's a <a href="https://en.wikipedia.org/wiki/Round-robin_scheduling" target="_blank"
                        rel="noopener noreferrer">Round-Robin</a> simple. The idea is to use it as fallback since the
                    main sched should be preemptive
                    and uses a simple priority scheme (CFS or something like that).
                    <br>
                    <br>
                    <strong>Files:</strong> scheduler/scheduler.c, scheduler/task.h, scheduler/switch/switch.asm.
                </p>
                <br>

            </div>

            <div class="info-card">
                <h2>Filesystem</h2>
                <p>
                    Based on <a href="https://es.wikipedia.org/wiki/Ext2" target="_blank"
                        rel="noopener noreferrer">EXT2</a> and made from scratch. The only innovation
                    would be to include optimization in search functions with a <a
                        href="https://github.com/victor-base/libvictor" target="_blank" rel="noopener noreferrer">vectorial database library</a>
                    that I contributed to.
                    <br>
                    <br>

                    <strong>Files:</strong> To implement.
                </p>
            </div>

            <div class="info-card">
                <h2>Interrupt System</h2>
                <p>
                    IDT of 256 entries, page fault handling, handlers and wrapper in assembly.
                    <br>
                    <br>

                    <strong>Files:</strong> interrupt/idt.c, interrupt/interrupt.asm, interrupt/isr_handlers.c with
                    their headers.
                </p>
            </div>

            <div class="info-card">
                <h2>Boot subsystem</h2>
                <p>
                    Boot depending on the architecture (X86_64) with entry point in ASM.
                    <br>
                    <br>

                    <img src="/Assets/diag.png" alt="diagramar" srcset="" style="width: 100%;">
                    <strong>Files:</strong> boot.asm, kmain.c arch.c, kernel_start.c.
                </p>
            </div>

        </section>

        <section id="descarga" class="section">
            <h1 class="titulo-guia">Downloads</h1>

            <div class="info-card">
                <p>
                    <li>The kernel binary download will be available in this section when the first stable version of the mainline branch is released.</li>
                </p>
                
                <div style="margin-top: 2rem; text-align: center;">
                    <h3>Wiki Versions</h3>
                    <button onclick="window.open('index.html', '_blank')" class="download-btn">
                        üìÑ View Spanish Version
                    </button>
                    <p style="margin-top: 1rem; color: #666; font-size: 0.9rem;">
                        Open the Spanish version of the wiki in a new tab.
                    </p>
                </div>
            </div>
        </section>
    </div>

</body>

</html>
