<!DOCTYPE html>
<html lang="en">
<!-- If you're reading this, first I already told you that I'm not using any trendy hipster framework like React, next, nest, whatever. At most Blazor. -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/Assets/cuatro-nucleos.png" type="image/x-icon">
    <title>IR0 Kernel - Wiki</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@300;400;500;700&family=Ubuntu+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <script src="main.js"></script>

    <nav class="navbar">
        <div class="nav-container">
            <div class="logo"><a href="index_en.html" target="_blank" rel="noopener noreferrer"
                    style="text-decoration: none; color: white;">IR0 Wiki</a></div>
            <ul class="nav-menu">
                <li><a href="#overview" class="nav-link active" onclick="showSection('overview')">Home</a></li>
                <li><a href="#architecture" class="nav-link" onclick="showSection('architecture')">Architecture</a></li>
                <li><a href="#branches" class="nav-link" onclick="showSection('branches')">Branches</a></li>
                <li><a href="#development" class="nav-link" onclick="showSection('development')">Development</a></li>
                <li><a href="#panic" class="nav-link" onclick="showSection('panic')">Subsystems</a></li>
                <li><a href="#overview" class="nav-link" onclick="showSection('descarga')">Download</a></li>
                <li class="language-dropdown">
                    <button class="translate-btn" onclick="toggleLanguageMenu()">üåê EN</button>
                    <div class="language-menu" id="languageMenu">
                        <a href="index.html" class="language-option">üá™üá∏ Espa√±ol</a>
                        <a href="index_en.html" class="language-option active">üá∫üá∏ English</a>
                    </div>
                </li>
                <li><button id="darkModeBtn" class="dark-mode-btn" onclick="toggleDarkMode()">üåô</button></li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <section id="overview" class="section active">
            <h1 class="titulo-principal">IR0 Kernel - Overview</h1>

            <div class="info-card">
                <p>
                    The purpose of this "wiki", web documentation, guide, however you call it, is to use it as a personal memory aid
                    for kernel development.
                    It doesn't have to be an ultra-aesthetic page, but I'm trying hard so it doesn't show that I made it
                    with vanilla html, css and js like some amateur project
                    that's out there. <br> <br>
                    A minimally functional operating system kernel (all the <a
                        href="https://en.wikipedia.org/wiki/User_space_and_kernel_space" target="_blank"
                        rel="noopener noreferrer">Kernel Space</a> plus a minimal user space)
                    can easily run in <strong>15,000</strong> lines of code, so as you'll see;
                    it's humanly impossible to memorize and understand the entire kernel flow by myself. Besides, there are many complex subsystems working together at a low level to mediate between hardware and software.
                </p>
            </div>

            <div class="info-card">
                <h2>What is IR0?</h2>
                <p>
                    <strong>IR0</strong> is a <strong>multipurpose operating system kernel</strong> developed
                    from scratch for <strong>x86-64</strong> architecture written primarily in <strong>C</strong> and <strong>ASM</strong> (Although
                    I have no problem including code from other specialized languages in performance such as
                    <strong>Cpp</strong> or <strong>Rust</strong>).
                    <br>
                    I'm creating it to learn more about operating systems and be able to use it as raw material
                    for another project that replicates <a href="https://learn.microsoft.com/es-es/windows/wsl/about"
                        target="_blank" rel="noopener noreferrer">WSL2</a> but with my own kernel.
                    I don't rule out scaling it enough to make it usable in minimal servers or even IoT,
                    but I understand that's in the very long term.
                    <br>
                    <br>
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank" rel="noopener noreferrer">This
                        is its GitHub Repository.</a>
                </p>
            </div>

            <div class="info-card">
                <h2>Main Features and Future Ones</h2>
                <ul class="feature-list">
                    <li>Monolithic kernel for x86-64 architecture</li>
                    <li>Memory management with paging in those two architectures</li>
                    <li>Interrupt and exception handling</li>
                    <li>Custom bootloader (Only in x86 and I'll probably migrate all architectures to GRUB)</li>
                    <li>The assembly code I use is in syntax of <a
                            href="https://cs.lmu.edu/~ray/notes/nasmtutorial/" target="_blank"
                            rel="noopener noreferrer">Intel Netwide Assembler (nasm)</a>.</li>
                    <li>Own filesystem based on EXT with vectorial database optimization in user space</li>
                    <li>Network stack and <a href="https://opensource.com/article/22/12/linux-abi" target="_blank"
                            rel="noopener noreferrer">ABI</a> borrowed from Linux (They are millions of lines of code that
                        I don't plan to write alone)</li>
                    <li>Own syscalls and some mapped from Linux</li>
                    <li>Some drivers for minimal hardware handling.</li>
                </ul>
            </div>

            <div class="info-card">
                <h2>Project Status</h2>
                <p><strong>Version:</strong> not yet versioned (but let's say pre-release for now.)<br>
                    <strong>Architecture:</strong> x86-64 (i386)<br>
                    <strong>Bootloader:</strong> GRUB<br>
                    <strong>ASM Syntax:</strong> Intel
                </p>
            </div>
        </section>

        <section id="architecture" class="section">
            <h1 class="titulo-principal">System Architecture</h1>

            <div class="architecture-box">
                <img src="Assets/scheme-core.png" alt="ir0-arch" srcset="">
            </div>
            <div class="info-card">
                <h2>Architecture and "Philosophy" of the project</h2>
                <p>
                    Unlike kernels such as <a href="https://en.wikipedia.org/wiki/Windows_NT" target="_blank"
                        rel="noopener noreferrer">Microsoft's NT kernel (Hybrid)</a>, <a
                        href="https://www.redox-os.org/" target="_blank" rel="noopener noreferrer">Redox-OS
                        (Microkernel)</a>,
                    or the same <a href="https://es.wikipedia.org/wiki/MINIX" target="_blank"
                        rel="noopener noreferrer">MINIX kernel (microkernel)</a>, IR0 is based on a more similar architecture
                    to what Linux has, which is monolithic.
                    <br>

                    However, my main argument is that of performance. I understand that someone could come and
                    point out that, like any monolith, if a subcomponent breaks, the entire system crashes <small>(and
                        they would be right)</small>
                    but what I respond to that is <i>"What good does it do me that the kernel supports continuing without
                        filesystem if I can't do anything practical without it?"</i>, that is, it doesn't make sense that the
                    kernel
                    continues functioning <strong>without one of its key components running</strong>. <br><br>

                    That's why I don't see a better alternative (for now) than the <a
                        href="https://es.wikipedia.org/wiki/N%C3%BAcleo_monol%C3%ADtico" target="_blank"
                        rel="noopener noreferrer">monolithic</a> pattern. And it also saves me from having to interconnect
                    key subsystems with each other via IPC, which impacts performance of the Operating System. It's not
                    perfect, but it's stable. It's not entirely traceable and requires scaling little by little, but if it scales well it performs a lot. <br>

                    <br>
                    However, I also have disagreements with the <a
                        href="https://es.wikipedia.org/wiki/Filosof%C3%ADa_de_Unix" target="_blank"
                        rel="noopener noreferrer">UNIX philosophy</a>. They (among other things and very briefly)
                    consider
                    that if something fails, <i>let it fail well</i>. Which in kernel terms would be: <i>If the scheduler breaks, Panic() directly. If you have memory corruption (in kernel space),
                        Panic.</i><br>
                    And it's not that I question it for no reason, I simply ask (although without solutions yet) <i>"Why not rescue the system during Panic()?, or at least try"</i>. <br>
                    Beyond the philosophical point and to summarize, the kernel is monolithic because it's more performant and
                    I feel that the key pieces of the kernel must <strong>work without overhead</strong>. <br>
                    However, if in the future I needed to integrate some specific subsystem in a hybrid way,
                    I would surely be pragmatic.
                </p>
                <h2>Kernel Space is sacred</h2>
                <p>
                    I know I talk as if IR0 were used by thousands of people and all the history, but I'm going to give myself the luxury of opining
                    about it.
                    <br>So, the point is that kernel space <strong>has to be only habitable by subsystems
                        that work in that Environment</strong>,
                    nothing else. <br>
                    I understand that there are certain <a
                        href="https://www.reddit.com/r/riotgames/comments/1gxhfmh/the_future_of_riot_vanguard_and_kernel_level/"
                        target="_blank" rel="noopener noreferrer">manufacturers concerned about their clients' security</a> who,
                    coincidentally, have access to <i>every interruption that the user makes (they know what keys you press,
                        your session time every time you turn on the computer, etc.)</i> And all that because they have
                    software running in the <a href="https://en.wikipedia.org/wiki/User_space_and_kernel_space"
                        target="_blank" rel="noopener noreferrer">kernel space</a> with all the privileges that implies.
                    <br> <a href="https://en.wikipedia.org/wiki/Protection_ring" target="_blank"
                        rel="noopener noreferrer">RING 0</a> is only for the kernel. Everything that comes from RING 3
                    communicates with <i>syscalls()</i>, end of statement.
                </p>
                <h2>What do I borrow from Linux?</h2>
                <p>
                    If I intend to make IR0 work as support for servers (backends, games, etc), that can run docker and kubernetes (at least) and that, at some point,
                    can work as a base for IoT, I need to have first of all <strong>network support, with its drivers, support for modern network protocols</strong> plus <strong>all the algorithms that
                        they implement internally</strong>.
                    <br><br>
                    In the Linux Kernel there are more or less <i>1,500,000</i> lines of code <strong>ONLY THE COMPLETE NETWORK STACK</strong>.
                    <br>
                    Literally, if I wanted to build it from scratch, maybe it would take a decade and it wouldn't be ready. I don't feel so crazy really.
                    <br><br>
                    I'll show you what I need from the network stack:
                    <br><br>
                    <img src="/Assets/deepseek_mermaid_20250808_234e4e.png" alt="chiquita la pilita de red" srcset=""
                        style="width: 50%;">
                    <br>
                    <small><i>Understand hardware as the components of your <a
                                href="https://es.wikipedia.org/wiki/Placa_base" target="_blank"
                                rel="noopener noreferrer"></a>MOBO</i> that talk to the kernel.
                        Besides, here you can see clearly how the kernel mediates between hard and soft.</small>
                    <br><br>

                    We have the same issue with <strong>container support</strong>. Here the issue is a bit calmer because there are a couple less lines of code in total: <i>some 300,000 lines</i>
                    but still, as happens with the network stack, they are two completely separate projects.
                    <br> <br>
                    More or less this is what docker requires to work, from the app with its runtime, to its accesses in the kernel.
                    <br><br>
                    <img src="/Assets/docker.png" alt="" srcset="" style="width: 101%;">
                    <br>
                    <small>Notice that docker needs to start literally a virtual file system, besides limiting the cpu, access RAM, have a private network interface, uses namespaces to isolate its content from the environment, etc.
                    </small>
                    <br>
                <h2>How am I going to solve it?</h2>
                Well, if writing the network stack and container support is not trivial, integrating them outside their environment isn't either, but it's more human than diagramming, implementing and testing.
                <br><br>
                I'll most likely have to map the syscalls that that part of Linux expects in <a
                    href="https://es.wikipedia.org/wiki/Wine" target="_blank" rel="noopener noreferrer">Wine/Proton</a> style,
                or copy some of the ones they use natively if they serve me later.
                </p>

            </div>

            <div class="info-card">
                <h2>Directory Structure</h2>
                <p>
                    How the file structure can change constantly, I prefer you consult it in the
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank"
                        rel="noopener noreferrer">GitHub Repository</a>.
                </p>

            </div>

        </section>

        <section id="branches" class="section">
            <h1 class="titulo-principal">Branch Management</h1>
            <div class="info-card">
                <h2>Git Workflow</h2>
                <div class="code-block">
                    <article>Since it's the first time I write a project of this caliber, what I'm looking for
                        is that the Workflow for kernel development be
                        as clean, predictable and scalable as possible.
                        <br>
                        <br>
                        For that I use 3 main git branches in the
                        process: mainline, dev and feature (which although feature is not in the repository, it's the one used as convention for
                        integrating new code).
                        Where only <strong>mainline</strong> and <strong>dev</strong> are the only 2 <i>upstream
                            branches</i>.
                        <br>
                        <br>
                        <strong>experimental</strong> is a branch
                        divergent to <strong>dev</strong>, and <strong>feature</strong> is the branch that is created to send
                        contributions.
                    </article>
                </div>
            </div>

            <!-- mainline BRANCH -->
            <div class="branch-grid">
                <div class="branch-card">
                    <div class="branch-title">mainline</div>
                    <div class="status-badge status-stable">STABLE</div>
                    <p><strong>-</strong> Main branch with stable and tested code.</p>

                    <h3>Characteristics</h3>
                    <ul class="feature-list">
                        <li>Only tested and functional code</li>
                        <li>Complete documentation</li>
                        <li>My base for rc's.</li>
                        <li><strong>mainline is sacred</strong>, since this branch <strong>has to compile and boot always</strong>. It's the most stable of the two upstream branches.
                        </li>
                    </ul>

                </div>
                <!-- DEV BRANCH -->
                <div class="branch-card">
                    <div class="branch-title">dev</div>
                    <div class="status-badge status-development">STAGING</div>
                    <p><strong>-</strong> Active development branch where new features are implemented and tested.
                    </p>

                    <h3>Characteristics:</h3>
                    <ul class="feature-list">
                        <li>It's the mirror of <strong>mainline</strong>.</li>
                        <li>What gets merged here doesn't have to go to <strong>mainline</strong>.</li>
                        <li>New features in development that convinced me of feature</li>
                        <li>Code patches, refactors and optimizations</li>
                        <li>It can contain temporary bugs that are resolved one way or another in this branch.</li>
                    </ul>

                </div>

                <!-- feat BRANCH -->
                <div class="branch-card">
                    <div class="branch-title">feature</div>
                    <div class="status-badge status-feat">DEVELOPMENT</div>
                    <p><strong>-</strong>
                        I add it because it's the branch where feats are created that later go to upstream
                        merging to <strong>dev</strong>. It's the most unstable of all because it's where new code is integrated that must also be tested and reviewed before reaching merge.
                    </p>

                    <h3>Characteristics:</h3>
                    <ul class="feature-list">
                        <li>This is where I start to implement new functionalities or patches</li>
                        <li>It's the first one that gets debugged.</li>
                        <li>It's the one you would create when you fork the repo.</li>
                        <li>It's expected to compile before going to <strong>dev</strong>.</li>
                    </ul>
                </div>
                <!-- exp BRANCH -->

                <div class="branch-card">
                    <div class="branch-title">experimental</div>
                    <div class="status-badge status-exp">MISC</div>
                    <p><strong>-</strong>
                        In this branch, features are integrated unstable enough to end up in
                        <strong>mainline</strong>
                        but that may have potential in the future.
                    </p>

                    <h3>Characteristics:</h3>
                    <ul class="feature-list">
                        <li>It's a pure testing branch, it has nothing to do with stable upstream branches</li>
                        <li>Here fall the features and experiments that don't reach <strong>mainline</strong></li>
                        <li>Things that aren't tested in operating systems or new ideas</li>
                        <li>Stability is not so important in this branch</li>
                        <li>If they are tested enough without breaking anything, they may or may not merge to mainline first
                            passing through <strong>dev</strong> again.
                        </li>
                    </ul>
                </div>

            </div>

            <div class="info-card">
                <h2>How is merging from feature to mainline?</h2>

                <article>
                    Basically, you create your improvement/optimization <strong>from a fork of the repo with a new branch</strong> that will be something like <i>"feature/fix-scheduler"</i> for example. <br>
                    Then, <strong>you make PR to the upstream dev branch (not to mainline)</strong> and the review and merge is done if applicable. <br>
                    The merge to mainline depends on <strong>how aligned with the project I consider the feature is</strong>. <br>
                    Not even some of my own implementations would I merge directly to mainline for this same reason.
                </article>

            </div>

        </section>

        <section id="development" class="section">
            <h1 class="titulo-guia">Development Guide</h1>

            <div class="info-card">
                <p>
                <div class="code-block">
                    <strong>-</strong> This section is in case someone is interested in contributing to the project. <strong>They are not
                        strict rules, they are simply recommendations
                        to make it more bearable.</strong>
                </div>
                </p>
                <h2>What do you need to know to contribute?</h2>
                More than anything the following:
                <li>Know structured/functional/object-oriented programming as necessary for the language.
                </li>
                <li>Know C or C++ or Rust.</li>
                <li>Assembly if you contribute to subsystems very close to the hardware, but I recommend knowing the basics to know how <i>panic(), boot.asm, etc.</i> work</li>
                <li><strong>Know how a makefile works</strong>, how to compile subsystems by parts, why
                    subsystems have to be compiled separately with their own makefile</li>
                <li><strong>General development tools</strong>: GIT/GitHub, how to create, change, pull and launch PR's between branches</li>
                <li><strong>Basic QEMU.</strong> How the VM works, how the generated image is loaded when compiling the kernel.</li>
                <li><strong>Knowing Bash is a plus for quick testing</strong>, since you can start QEMU with a script without repeating the complete command.</li>
                <li>Communication. <strong>Argue decisions about PR's</strong>, debate healthily about it.
                </li>
                <li>Know how to use AI's in general to optimize debugging and adapt it to code conventions.
                </li>
                <li>Know that, when contributing, <strong>you can be maintainer of the subsystem you contributed to</strong>. And if
                    you can't provide maintenance recurrent to the subsystem, <strong>leave it well documented</strong>.</li>
                <br>
                    Similarly, <strong>you don't have to be an expert to contribute to the kernel. Simply with having the desire
                    to learn/study about what you're going to contribute is more than enough</strong>.

                <h2>Environment Setup</h2>
                <h3>Required Dependencies:</h3>
                <li>Basically have installed: the C/Cpp compiler (gcc/g++), the asm compiler (nasm), make
                    for compilation and
                    QEMU as test vm.
                </li>
                I would give you the commands or websites to install, but chatgpt can solve it better for you.
                <br><br>

                <div class="code-block">
                    <strong>NOTE</strong>: Since this project is a kernel, it's <i>Freestanding</i>. That means you
                    <strong>can't include libraries like
                        stdio.h to do a <code>print(), write()</code>, etc. because there's no operating system that
                        responds to those functions </strong>. <strong>You are the
                        operating system</strong>. that's why, in the repo I have the folder of dependencies "includes".
                    </strong>
                </div>

            </div>
            <div class="info-card">
                <h2>How do I write code?</h2>
                <h3>Naming Conventions:</h3>
                <ul class="feature-list">
                    <li>Functions: <code>snake_case()</code></li>
                    <li>Macros: <code>UPPER_CASE</code></li>
                    <li>Structs: <code>struct_name_t</code></li>
                    <li>Global variables: <code>g_variable_name</code></li>
                    <li>Constants: <code>CONSTANT_NAME</code></li>
                    <li>includes: <code>#INCLUDE -ir0/Lib.h - </code>(are being migrated to that format)</li>
                </ul>
                <h3>Comments:</h3>
                <ul class="feature-list">
                    <li>header files .h of documented functions</li>
                    <li>Source code files with comments in some functions, but more limited</li>
                    <li>Explanation of complex algorithms</li>
                    <li>TO DO's clearly marked</li>
                    <li>References to technical documentation</li>
                </ul>
                <small>This is approximate. I generally try to respect those conventions as much as I can.</small>
                <br><br>
                <li>Something like this would be in this example an average source code file:</li>
                <br>
                <img src="/Assets/funcion.c.png" alt="" srcset="" style="width: 50%;">
                <br>
                <i>Notice how I use the braces below the function name and the same in conditionals,
                    loops, etc. Also how I don't use them directly when the conditional has a single line
                    or there's certain nesting.</i>
                <br>
                <br>
                <li>This is how I handle headers (or most):</li>
                <br><br>
                <img src="/Assets/encabezado.png" alt="" srcset="">
                <br>
                <i>Large comments usually go in these .h and in the source we make notes.</i>
            </div>

            <div class="info-card">
                <h2>How to compile (for now)</h2>
                <div class="code-block">
                    <li>There must be a makefile in all subsystems, so it should be possible to do <i>make
                            "subsystem"</i></li> <br>
                    <li>Then, the kernel has a general makefile to generate the binary, with its respective clean.
                        For now it's used like this: <i>make all</i></li> <br>
                    <li>In the future, there will surely be compilation strategies that allow compiling the entire kernel
                        for its different uses.</li>
                </div>
            </div>
        </section>

        <section id="panic" class="section">
            <h1 class="titulo-guia">Kernel Subsystems</h1>
            <div class="code-block">
                <p>
                    <strong>-</strong> This section details the main subsystems that compose the IR0 kernel,
                    their current development status and technical characteristics of each one.
                    <br>
                    <br>
                    The best way to understand the internal operation is by reviewing the source code in the
                    <a href="https://github.com/IRodriguez13/IR0-Kernel" target="_blank"
                        rel="noopener noreferrer" class="link-repo">GitHub Repository</a>.
                </p>
            </div>

            <div class="info-card">
                <h2>üîÑ Scheduler</h2>
                <p>
                    The scheduler is the heart of the multiprocessing system. Currently implements a simple
                    <a href="https://en.wikipedia.org/wiki/Round-robin_scheduling" target="_blank"
                        rel="noopener noreferrer">Round-Robin</a> algorithm as fallback, but the goal is to migrate to a
                    preemptive scheduler with priority scheme similar to Linux's CFS (Completely Fair Scheduler).
                </p>
                <h3>Current Features:</h3>
                <ul class="feature-list">
                    <li>Round-Robin algorithm with fixed quantum</li>
                    <li>Support for multiple priority levels</li>
                    <li>Basic process state management (Ready, Running, Blocked)</li>
                    <li>Optimized context switching in assembly</li>
                </ul>
                <h3>Upcoming Improvements:</h3>
                <ul class="feature-list">
                    <li>Preemptive scheduler implementation</li>
                    <li>CFS algorithm for fair CPU distribution</li>
                    <li>Real-time scheduling support</li>
                    <li>Load balancing between cores</li>
                </ul>
                <p><strong>Files:</strong> scheduler/scheduler.c, scheduler/task.h, scheduler/switch/switch.asm</p>
            </div>

            <div class="info-card">
                <h2>üíæ Filesystem</h2>
                <p>
                    Own filesystem based on <a href="https://es.wikipedia.org/wiki/Ext2" target="_blank"
                        rel="noopener noreferrer">EXT2</a> but with modern innovations. The distinctive feature
                    is the integration of a vectorial database to optimize file search and indexing operations.
                </p>
                <h3>Technical Features:</h3>
                <ul class="feature-list">
                    <li>Hierarchical directory structure</li>
                    <li>Support for files up to 2TB</li>
                    <li>Journaling for failure recovery</li>
                    <li>Transparent file compression</li>
                    <li>Vectorial indexing for fast searches</li>
                </ul>
                <h3>Innovations:</h3>
                <ul class="feature-list">
                    <li>Integration with <a href="https://github.com/victor-base/libvictor" target="_blank" rel="noopener noreferrer">libvictor</a> for semantic searches</li>
                    <li>Intelligent cache based on access patterns</li>
                    <li>Extended metadata support</li>
                    <li>File-level encryption</li>
                </ul>
                <p><strong>Status:</strong> Active development</p>
                <p><strong>Files:</strong> fs/ext2.c, fs/victor_index.c, fs/journal.c</p>
            </div>

            <div class="info-card">
                <h2>‚ö° Interrupt System</h2>
                <p>
                    Robust interrupt and exception handling system that ensures kernel stability
                    and provides a clean interface for handling hardware and software events.
                </p>
                <h3>Main Components:</h3>
                <ul class="feature-list">
                    <li><strong>IDT (Interrupt Descriptor Table):</strong> 256-entry table for interrupt mapping</li>
                    <li><strong>ISR (Interrupt Service Routines):</strong> Optimized handlers in assembly</li>
                    <li><strong>Exception Handler:</strong> Processor exception handling</li>
                    <li><strong>IRQ Manager:</strong> Hardware interrupt management</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Complete page fault handling with automatic recovery</li>
                    <li>Nested interrupts with priorities</li>
                    <li>Deferred interrupt processing</li>
                    <li>Interrupt coalescing for optimization</li>
                </ul>
                <p><strong>Files:</strong> interrupt/idt.c, interrupt/interrupt.asm, interrupt/isr_handlers.c, interrupt/irq.c</p>
            </div>

            <div class="info-card">
                <h2>üöÄ Boot Subsystem</h2>
                <p>
                    Initialization system that prepares the environment for kernel execution, handling the
                    transition from bootloader to user space.
                </p>
                <h3>Boot Phases:</h3>
                <ul class="feature-list">
                    <li><strong>Phase 1:</strong> Processor initialization and protected mode</li>
                    <li><strong>Phase 2:</strong> Paging and virtual memory configuration</li>
                    <li><strong>Phase 3:</strong> Critical subsystems initialization</li>
                    <li><strong>Phase 4:</strong> First process loading (init)</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Support for multiple architectures (x86-64, ARM64)</li>
                    <li>Independent bootloader with UEFI support</li>
                    <li>Automatic recovery from boot failures</li>
                    <li>Integrated recovery mode</li>
                </ul>
                <img src="/Assets/diag.png" alt="Boot diagram" srcset="" style="width: 100%;">
                <p><strong>Files:</strong> boot/boot.asm, boot/kmain.c, boot/arch.c, boot/kernel_start.c</p>
            </div>

            <div class="info-card">
                <h2>üõ°Ô∏è Memory Management</h2>
                <p>
                    Advanced memory management system that provides process isolation, performance optimization
                    and protection against unauthorized access.
                </p>
                <h3>Components:</h3>
                <ul class="feature-list">
                    <li><strong>Memory Manager:</strong> Physical and virtual page management</li>
                    <li><strong>Page Allocator:</strong> Efficient memory allocation</li>
                    <li><strong>Slab Allocator:</strong> Optimization for small objects</li>
                    <li><strong>Memory Protection:</strong> Access control and permissions</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>4-level paging (48-bit addressing)</li>
                    <li>Transparent memory compression</li>
                    <li>NUMA awareness for multi-socket systems</li>
                    <li>Memory deduplication</li>
                </ul>
                <p><strong>Files:</strong> mm/page_alloc.c, mm/slab.c, mm/vmalloc.c, mm/protection.c</p>
            </div>

            <div class="info-card">
                <h2>üåê Network Subsystem</h2>
                <p>
                    Complete network stack based on Linux but optimized for the IR0 kernel, providing
                    support for modern protocols and specific optimizations.
                </p>
                <h3>Supported Protocols:</h3>
                <ul class="feature-list">
                    <li>Complete TCP/IP stack</li>
                    <li>UDP with latency optimizations</li>
                    <li>HTTP/2 and HTTP/3</li>
                    <li>QUIC for fast connections</li>
                    <li>IPv6 with automatic transition</li>
                </ul>
                <h3>Optimizations:</h3>
                <ul class="feature-list">
                    <li>Zero-copy networking</li>
                    <li>Kernel bypass for high-performance applications</li>
                    <li>Network function virtualization (NFV)</li>
                    <li>Intelligent load balancing</li>
                </ul>
                <p><strong>Status:</strong> Integration with Linux networking stack</p>
                <p><strong>Files:</strong> net/tcp.c, net/udp.c, net/socket.c, net/protocols/</p>
            </div>

            <div class="info-card">
                <h2>üîß Driver Subsystem</h2>
                <p>
                    Modular framework for hardware driver development and management, with support for
                    hot-plugging and automatic device management.
                </p>
                <h3>Driver Types:</h3>
                <ul class="feature-list">
                    <li><strong>Block Devices:</strong> Disks, SSDs, storage devices</li>
                    <li><strong>Character Devices:</strong> Terminals, input devices</li>
                    <li><strong>Network Devices:</strong> Network cards, WiFi, Bluetooth</li>
                    <li><strong>Graphics:</strong> GPUs, framebuffers, hardware acceleration</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Unified driver framework</li>
                    <li>Hardware auto-detection</li>
                    <li>Integrated power management</li>
                    <li>Driver signing and verification</li>
                </ul>
                <p><strong>Files:</strong> drivers/core.c, drivers/block/, drivers/char/, drivers/net/</p>
            </div>

            <div class="info-card">
                <h2>üîê Security System</h2>
                <p>
                    Comprehensive security framework that protects the kernel and user processes, implementing
                    multiple layers of protection and security auditing.
                </p>
                <h3>Security Components:</h3>
                <ul class="feature-list">
                    <li><strong>Access Control:</strong> Role-based access control (RBAC)</li>
                    <li><strong>Capability System:</strong> Granular capability system</li>
                    <li><strong>Seccomp:</strong> Syscall filtering for sandboxing</li>
                    <li><strong>LSM (Linux Security Modules):</strong> Interchangeable security modules</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>ASLR (Address Space Layout Randomization)</li>
                    <li>Stack canaries and buffer overflow protection</li>
                    <li>Automatic kernel hardening</li>
                    <li>Security event auditing</li>
                    <li>TPM integration for integrity measurement</li>
                </ul>
                <p><strong>Files:</strong> security/capability.c, security/seccomp.c, security/lsm/, security/audit.c</p>
            </div>

            <div class="info-card">
                <h2>‚ö° Power Management</h2>
                <p>
                    Advanced power management system that optimizes battery consumption in mobile devices
                    and reduces energy consumption in servers while maintaining performance.
                </p>
                <h3>Power States:</h3>
                <ul class="feature-list">
                    <li><strong>Suspend to RAM:</strong> Fast suspension with instant recovery</li>
                    <li><strong>Suspend to Disk:</strong> Complete hibernation</li>
                    <li><strong>Standby:</strong> Low-power standby mode</li>
                    <li><strong>Dynamic Frequency Scaling:</strong> Dynamic CPU frequency adjustment</li>
                </ul>
                <h3>Optimizations:</h3>
                <ul class="feature-list">
                    <li>Intelligent CPU idle management</li>
                    <li>Wake-on-LAN and wake-on-timer</li>
                    <li>Power capping for servers</li>
                    <li>Automatic thermal management</li>
                    <li>Battery health monitoring</li>
                </ul>
                <p><strong>Files:</strong> power/suspend.c, power/cpuidle.c, power/thermal.c, power/battery.c</p>
            </div>

            <div class="info-card">
                <h2>üéØ Virtualization</h2>
                <p>
                    Virtualization subsystem that allows running multiple operating systems simultaneously,
                    with support for containers and complete virtual machines.
                </p>
                <h3>Virtualization Types:</h3>
                <ul class="feature-list">
                    <li><strong>Containers:</strong> Light isolation with namespaces and cgroups</li>
                    <li><strong>KVM:</strong> Kernel-based Virtual Machine for complete VMs</li>
                    <li><strong>Xen:</strong> Type 1 hypervisor for bare-metal virtualization</li>
                    <li><strong>Docker/OCI:</strong> Support for container standards</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Hardware-assisted virtualization (Intel VT-x, AMD-V)</li>
                    <li>Nested virtualization</li>
                    <li>Live VM migration</li>
                    <li>GPU passthrough for graphics acceleration</li>
                    <li>Memory ballooning and overcommit</li>
                </ul>
                <p><strong>Files:</strong> virt/kvm/, virt/xen/, kernel/nsproxy.c, kernel/cgroup.c</p>
            </div>

            <div class="info-card">
                <h2>üìä Monitoring and Debugging</h2>
                <p>
                    Complete monitoring and debugging system that provides deep visibility into kernel operation
                    and enables real-time problem diagnosis.
                </p>
                <h3>Debugging Tools:</h3>
                <ul class="feature-list">
                    <li><strong>Kprobes:</strong> Dynamic insertion points in the kernel</li>
                    <li><strong>ftrace:</strong> Function and event tracer</li>
                    <li><strong>perf:</strong> Advanced performance profiler</li>
                    <li><strong>eBPF:</strong> Dynamic kernel programming</li>
                </ul>
                <h3>Metrics and Monitoring:</h3>
                <ul class="feature-list">
                    <li>CPU, memory and I/O profiling</li>
                    <li>Network packet tracing</li>
                    <li>System call monitoring</li>
                    <li>Kernel panic analysis</li>
                    <li>Performance counters</li>
                </ul>
                <p><strong>Files:</strong> kernel/trace/, kernel/debug/, kernel/profiling/, kernel/bpf/</p>
            </div>

            <div class="info-card">
                <h2>üîß Device Tree</h2>
                <p>
                    Hardware description system that allows the kernel to automatically discover and configure
                    hardware devices without needing hardcoded specific drivers.
                </p>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Declarative hardware description</li>
                    <li>Support for multiple architectures</li>
                    <li>Dynamic overlays for configuration</li>
                    <li>UEFI/ACPI firmware compatibility</li>
                </ul>
                <h3>Benefits:</h3>
                <ul class="feature-list">
                    <li>Faster boot on embedded systems</li>
                    <li>Automatic device configuration</li>
                    <li>Cross-platform portability</li>
                    <li>Reduction of platform-specific code</li>
                </ul>
                <p><strong>Files:</strong> drivers/of/, drivers/acpi/, drivers/firmware/</p>
            </div>

            <div class="info-card">
                <h2>üéÆ Graphics and Multimedia</h2>
                <p>
                    Graphics subsystem that provides hardware acceleration, multi-monitor support
                    and advanced multimedia capabilities.
                </p>
                <h3>Graphics Components:</h3>
                <ul class="feature-list">
                    <li><strong>DRM (Direct Rendering Manager):</strong> Modern graphics management</li>
                    <li><strong>KMS (Kernel Mode Setting):</strong> Display mode configuration</li>
                    <li><strong>GEM (Graphics Execution Manager):</strong> Graphics memory management</li>
                    <li><strong>V4L2:</strong> Video4Linux for video capture</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Support for modern GPUs (NVIDIA, AMD, Intel)</li>
                    <li>Hardware video acceleration</li>
                    <li>Multi-head display</li>
                    <li>HDR and color management</li>
                    <li>VR/AR support</li>
                </ul>
                <p><strong>Files:</strong> drivers/gpu/drm/, drivers/media/, drivers/video/</p>
            </div>

            <div class="info-card">
                <h2>üîä Audio Subsystem</h2>
                <p>
                    Advanced audio system that provides support for multiple formats, real-time audio processing
                    and management of complex audio devices.
                </p>
                <h3>Audio Components:</h3>
                <ul class="feature-list">
                    <li><strong>ALSA (Advanced Linux Sound Architecture):</strong> Main audio framework</li>
                    <li><strong>PulseAudio:</strong> Sound server for users</li>
                    <li><strong>JACK:</strong> Low-latency professional audio</li>
                    <li><strong>ASoC (ALSA System on Chip):</strong> Audio for embedded systems</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>HD format support (24-bit, 192kHz)</li>
                    <li>7.1 surround audio</li>
                    <li>Noise cancellation</li>
                    <li>Bluetooth audio (A2DP, aptX)</li>
                    <li>MIDI and audio synthesis</li>
                </ul>
                <p><strong>Files:</strong> sound/core/, sound/soc/, sound/pci/, sound/usb/</p>
            </div>

            <div class="info-card">
                <h2>üì± Input/Output Subsystem</h2>
                <p>
                    Unified input and output system that handles all user interface devices,
                    from keyboards and mice to touchscreens and sensors.
                </p>
                <h3>Device Types:</h3>
                <ul class="feature-list">
                    <li><strong>HID (Human Interface Devices):</strong> Keyboards, mice, gamepads</li>
                    <li><strong>Touchscreens:</strong> Capacitive and resistive touchscreens</li>
                    <li><strong>Sensors:</strong> Accelerometers, gyroscopes, magnetometers</li>
                    <li><strong>Haptic Feedback:</strong> Vibration and tactile feedback</li>
                </ul>
                <h3>Features:</h3>
                <ul class="feature-list">
                    <li>Multi-touch support</li>
                    <li>Gesture recognition</li>
                    <li>Accessibility features</li>
                    <li>Automatic hot-plugging</li>
                    <li>Device power management</li>
                </ul>
                <p><strong>Files:</strong> drivers/input/, drivers/hid/, drivers/iio/</p>
            </div>

        </section>

        <section id="descarga" class="section">
            <h1 class="titulo-guia">Downloads</h1>

            <div class="info-card">
                <p>
                    <li>The kernel binary download will be available in this section when the first stable version of the mainline branch is released.</li>
                </p>
                
            
            </div>
        </section>
    </div>

</body>

</html>
